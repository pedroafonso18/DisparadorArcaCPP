<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Config.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Config.cpp" />
              <option name="originalContent" value="#include &quot;../include/Config.h&quot;&#10;#include &quot;../third_party/dotenv.h&quot;&#10;#include &lt;memory&gt;&#10;&#10;Config::Config() : env(std::make_unique&lt;Env&gt;()){&#10;    const std::string root_path = &quot;../.env&quot;;&#10;    dotenv::init(root_path.c_str());&#10;}&#10;&#10;const Config::Env &amp;Config::GetEnv() const {&#10;    env-&gt;DbUrl = dotenv::getenv(&quot;DB_URL&quot;);&#10;    env-&gt;DbUrlTrafego = dotenv::getenv(&quot;DB_URL_TRAFEGO&quot;);&#10;    env-&gt;DbUrlV3 = dotenv::getenv(&quot;DB_URL_V3&quot;);&#10;    env-&gt;LoginArca = dotenv::getenv(&quot;LOGIN_ARCA&quot;);&#10;    env-&gt;PasswordArca = dotenv::getenv(&quot;PASSWORD_ARCA&quot;);&#10;&#10;    return *env;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/Config.h&quot;&#13;&#10;#include &quot;../third_party/dotenv.h&quot;&#13;&#10;#include &lt;memory&gt;&#13;&#10;#include &lt;iostream&gt;&#13;&#10;&#13;&#10;Config::Config() : env(std::make_unique&lt;Env&gt;()){&#13;&#10;    std::clog &lt;&lt; &quot;[Config::Config] Initializing dotenv with ../.env&quot; &lt;&lt; std::endl;&#13;&#10;    const std::string root_path = &quot;../.env&quot;;&#13;&#10;    dotenv::init(root_path.c_str());&#13;&#10;}&#13;&#10;&#13;&#10;const Config::Env &amp;Config::GetEnv() const {&#13;&#10;    std::clog &lt;&lt; &quot;[Config::GetEnv] Loading environment variables&quot; &lt;&lt; std::endl;&#13;&#10;    env-&gt;DbUrl = dotenv::getenv(&quot;DB_URL&quot;);&#13;&#10;    env-&gt;DbUrlTrafego = dotenv::getenv(&quot;DB_URL_TRAFEGO&quot;);&#13;&#10;    env-&gt;DbUrlV3 = dotenv::getenv(&quot;DB_URL_V3&quot;);&#13;&#10;    env-&gt;LoginArca = dotenv::getenv(&quot;LOGIN_ARCA&quot;);&#13;&#10;    env-&gt;PasswordArca = dotenv::getenv(&quot;PASSWORD_ARCA&quot;);&#13;&#10;    std::clog &lt;&lt; &quot;[Config::GetEnv] DB_URL: &quot; &lt;&lt; env-&gt;DbUrl &lt;&lt; std::endl;&#13;&#10;    std::clog &lt;&lt; &quot;[Config::GetEnv] DB_URL_TRAFEGO: &quot; &lt;&lt; env-&gt;DbUrlTrafego &lt;&lt; std::endl;&#13;&#10;    std::clog &lt;&lt; &quot;[Config::GetEnv] DB_URL_V3: &quot; &lt;&lt; env-&gt;DbUrlV3 &lt;&lt; std::endl;&#13;&#10;    std::clog &lt;&lt; &quot;[Config::GetEnv] LOGIN_ARCA: &quot; &lt;&lt; env-&gt;LoginArca &lt;&lt; std::endl;&#13;&#10;    // Do not log password for security&#13;&#10;    return *env;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Database/Fetch.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Database/Fetch.cpp" />
              <option name="originalContent" value="#include &quot;../../include/Database/Fetch.h&quot;&#10;&#10;#include &lt;iostream&gt;&#10;&#10;std::vector&lt;EntradaClt&gt; Fetch::FetchBolsa() {&#10;    std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Fetching Bolsa leads from database&quot; &lt;&lt; std::endl;&#10;    std::vector&lt;EntradaClt&gt; vec;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return vec;&#10;    }&#10;&#10;    pqxx::work transaction(*c);&#10;    const std::string query = R&quot;(SELECT DISTINCT ON (telefone)&#10;&#9;&#9;carteira_assinada, tempo_emprego, valor_desejado, nome, cpf, telefone, tag, produto, processado&#10;&#9;&#9;FROM entrada_clt&#10;&#9;&#9;WHERE processado = FALSE AND produto = 'bolsa-familia'&#10;&#9;&#9;AND tag != 'base'&#10;&#9;&#9;ORDER BY telefone, random()&#10;&#9;&#9;LIMIT 45;)&quot;;&#10;    try {&#10;        auto result = transaction.exec(pqxx::zview(query));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Query 1 returned &quot; &lt;&lt; result.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        if (!result.empty()) {&#10;            for (auto row: result) {&#10;                EntradaClt e;&#10;                e.CarteiraAssinada = row[0].as&lt;std::string&gt;();&#10;                e.TempoEmprego = row[1].as&lt;std::string&gt;();&#10;                e.ValorDesejado = row[2].as&lt;std::string&gt;();&#10;                e.Nome = row[3].as&lt;std::string&gt;();&#10;                e.Cpf = row[4].as&lt;std::string&gt;();&#10;                e.Telefone = row[5].as&lt;std::string&gt;();&#10;                e.Tag = row[6].as&lt;std::string&gt;();&#10;                e.Produto = row[7].as&lt;std::string&gt;();&#10;                e.Processado = row[8].as&lt;std::string&gt;();&#10;                std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Lead: &quot; &lt;&lt; e.Telefone &lt;&lt; &quot;, Tag: &quot; &lt;&lt; e.Tag &lt;&lt; std::endl;&#10;                vec.push_back(e);&#10;            }&#10;            return vec;&#10;        }&#10;        auto res2 = transaction.exec(pqxx::zview(R&quot;(SELECT DISTINCT ON (telefone)&#10;&#9;&#9;&#9;carteira_assinada, tempo_emprego, valor_desejado, nome, cpf, telefone, tag, produto, processado&#10;&#9;&#9;&#9;FROM entrada_clt&#10;&#9;&#9;&#9;WHERE processado = FALSE AND produto = 'bolsa-familia'&#10;&#9;&#9;&#9;AND tag = 'base'&#10;&#9;&#9;&#9;AND status_cref-&gt;'costumer_data'-&gt;&gt;'erro' = 'false'&#10;&#9;&#9;&#9;AND status_cref-&gt;'costumer_data'-&gt;'objeto'-&gt;&gt;'permiteCaptura' = 'true'&#10;&#9;&#9;&#9;AND status_cref-&gt;'costumer_data'-&gt;'objeto'-&gt;&gt;'mensagem' = 'Prosseguir com simulação'&#10;&#9;&#9;&#9;ORDER BY telefone, random()&#10;&#9;&#9;&#9;LIMIT 45;)&quot;));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Query 2 returned &quot; &lt;&lt; res2.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        if (!res2.empty()) {&#10;            for (auto row: result) {&#10;                EntradaClt e;&#10;                e.CarteiraAssinada = row[0].as&lt;std::string&gt;();&#10;                e.TempoEmprego = row[1].as&lt;std::string&gt;();&#10;                e.ValorDesejado = row[2].as&lt;std::string&gt;();&#10;                e.Nome = row[3].as&lt;std::string&gt;();&#10;                e.Cpf = row[4].as&lt;std::string&gt;();&#10;                e.Telefone = row[5].as&lt;std::string&gt;();&#10;                e.Tag = row[6].as&lt;std::string&gt;();&#10;                e.Produto = row[7].as&lt;std::string&gt;();&#10;                e.Processado = row[8].as&lt;std::string&gt;();&#10;                std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Lead: &quot; &lt;&lt; e.Telefone &lt;&lt; &quot;, Tag: &quot; &lt;&lt; e.Tag &lt;&lt; std::endl;&#10;                vec.push_back(e);&#10;            }&#10;            return vec;&#10;        }&#10;        return vec;&#10;    } catch (pqxx::sql_error const &amp;e) {&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] SQL error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        transaction.abort();&#10;        return vec;&#10;    }&#10;}&#10;&#10;&#10;std::string Fetch::FetchTemplates() const {&#10;    std::clog &lt;&lt; &quot;[Fetch::FetchTemplates] Fetching template from database&quot; &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    const std::string query = R&quot;(SELECT template_texto FROM templates_anas WHERE is_active = true LIMIT 1;)&quot;;&#10;    try {&#10;        const auto result = transaction.exec(pqxx::zview(query));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchTemplates] Query returned &quot; &lt;&lt; result.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        transaction.commit();&#10;        return result[0][0].as&lt;std::string&gt;();&#10;    } catch (const pqxx::sql_error&amp; e) {&#10;        std::clog &lt;&lt; &quot;SQL error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;}&#10;&#10;&#10;const std::vector&lt;Instance&gt; Fetch::FetchInstances() const {&#10;    std::clog &lt;&lt; &quot;[Fetch::FetchInstances] Fetching instances from database&quot; &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    std::vector&lt;Instance&gt; vec;&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return vec;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    const std::string query = &quot;SELECT connection_name, connection_number, connection_token, daily_limit, sent_today FROM parametros_disparos WHERE is_active = true AND is_banned = false AND sent_today &lt; daily_limit&quot;;&#10;    try {&#10;        auto res = transaction.exec(pqxx::zview(query));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchInstances] Query returned &quot; &lt;&lt; res.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        for (auto row: res) {&#10;            Instance inst;&#10;            inst.InstanceName = row[0].as&lt;std::string&gt;();&#10;            inst.InstanceNumber = row[1].as&lt;std::string&gt;();&#10;            inst.Token = row[2].as&lt;std::string&gt;();&#10;            inst.DailyLimit = row[3].as&lt;int&gt;();&#10;            inst.SentToday = row[4].as&lt;int&gt;();&#10;            std::clog &lt;&lt; &quot;[Fetch::FetchInstances] Instance: &quot; &lt;&lt; inst.InstanceNumber &lt;&lt; &quot;, SentToday: &quot; &lt;&lt; inst.SentToday &lt;&lt; &quot;, DailyLimit: &quot; &lt;&lt; inst.DailyLimit &lt;&lt; std::endl;&#10;            vec.push_back(inst);&#10;        }&#10;        return vec;&#10;    } catch (const pqxx::sql_error&amp; e) {&#10;        std::clog &lt;&lt; &quot;SQL error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return vec;&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return vec;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../../include/Database/Fetch.h&quot;&#10;&#10;#include &lt;iostream&gt;&#10;&#10;std::vector&lt;EntradaClt&gt; Fetch::FetchBolsa() {&#10;    std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Fetching Bolsa leads from database&quot; &lt;&lt; std::endl;&#10;    std::vector&lt;EntradaClt&gt; vec;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return vec;&#10;    }&#10;&#10;    pqxx::work transaction(*c);&#10;    const std::string query = R&quot;(SELECT DISTINCT ON (telefone)&#10;&#9;&#9;carteira_assinada, tempo_emprego, valor_desejado, nome, cpf, telefone, tag, produto, processado&#10;&#9;&#9;FROM entrada_clt&#10;&#9;&#9;WHERE processado = FALSE AND produto = 'bolsa-familia'&#10;&#9;&#9;AND tag != 'base'&#10;&#9;&#9;ORDER BY telefone, random()&#10;&#9;&#9;LIMIT 45;)&quot;;&#10;    try {&#10;        auto result = transaction.exec(pqxx::zview(query));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Query 1 returned &quot; &lt;&lt; result.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        if (!result.empty()) {&#10;            for (auto row: result) {&#10;                EntradaClt e;&#10;                e.CarteiraAssinada = row[0].is_null() ? &quot;&quot; : row[0].as&lt;std::string&gt;();&#10;                e.TempoEmprego = row[1].is_null() ? &quot;&quot; : row[1].as&lt;std::string&gt;();&#10;                e.ValorDesejado = row[2].is_null() ? &quot;&quot; : row[2].as&lt;std::string&gt;();&#10;                e.Nome = row[3].is_null() ? &quot;&quot; : row[3].as&lt;std::string&gt;();&#10;                e.Cpf = row[4].is_null() ? &quot;&quot; : row[4].as&lt;std::string&gt;();&#10;                e.Telefone = row[5].is_null() ? &quot;&quot; : row[5].as&lt;std::string&gt;();&#10;                e.Tag = row[6].is_null() ? &quot;&quot; : row[6].as&lt;std::string&gt;();&#10;                e.Produto = row[7].is_null() ? &quot;&quot; : row[7].as&lt;std::string&gt;();&#10;                e.Processado = row[8].is_null() ? &quot;&quot; : row[8].as&lt;std::string&gt;();&#10;                std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Lead: &quot; &lt;&lt; e.Telefone &lt;&lt; &quot;, Tag: &quot; &lt;&lt; e.Tag &lt;&lt; std::endl;&#10;                vec.push_back(e);&#10;            }&#10;            return vec;&#10;        }&#10;        auto res2 = transaction.exec(pqxx::zview(R&quot;(SELECT DISTINCT ON (telefone)&#10;&#9;&#9;&#9;carteira_assinada, tempo_emprego, valor_desejado, nome, cpf, telefone, tag, produto, processado&#10;&#9;&#9;&#9;FROM entrada_clt&#10;&#9;&#9;&#9;WHERE processado = FALSE AND produto = 'bolsa-familia'&#10;&#9;&#9;&#9;AND tag = 'base'&#10;&#9;&#9;&#9;AND status_cref-&gt;'costumer_data'-&gt;&gt;'erro' = 'false'&#10;&#9;&#9;&#9;AND status_cref-&gt;'costumer_data'-&gt;'objeto'-&gt;&gt;'permiteCaptura' = 'true'&#10;&#9;&#9;&#9;AND status_cref-&gt;'costumer_data'-&gt;'objeto'-&gt;&gt;'mensagem' = 'Prosseguir com simulação'&#10;&#9;&#9;&#9;ORDER BY telefone, random()&#10;&#9;&#9;&#9;LIMIT 45;)&quot;));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Query 2 returned &quot; &lt;&lt; res2.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        if (!res2.empty()) {&#10;            for (auto row: res2) {&#10;                EntradaClt e;&#10;                e.CarteiraAssinada = row[0].is_null() ? &quot;&quot; : row[0].as&lt;std::string&gt;();&#10;                e.TempoEmprego = row[1].is_null() ? &quot;&quot; : row[1].as&lt;std::string&gt;();&#10;                e.ValorDesejado = row[2].is_null() ? &quot;&quot; : row[2].as&lt;std::string&gt;();&#10;                e.Nome = row[3].is_null() ? &quot;&quot; : row[3].as&lt;std::string&gt;();&#10;                e.Cpf = row[4].is_null() ? &quot;&quot; : row[4].as&lt;std::string&gt;();&#10;                e.Telefone = row[5].is_null() ? &quot;&quot; : row[5].as&lt;std::string&gt;();&#10;                e.Tag = row[6].is_null() ? &quot;&quot; : row[6].as&lt;std::string&gt;();&#10;                e.Produto = row[7].is_null() ? &quot;&quot; : row[7].as&lt;std::string&gt;();&#10;                e.Processado = row[8].is_null() ? &quot;&quot; : row[8].as&lt;std::string&gt;();&#10;                std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Lead: &quot; &lt;&lt; e.Telefone &lt;&lt; &quot;, Tag: &quot; &lt;&lt; e.Tag &lt;&lt; std::endl;&#10;                vec.push_back(e);&#10;            }&#10;            return vec;&#10;        }&#10;        return vec;&#10;    } catch (pqxx::sql_error const &amp;e) {&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] SQL error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        transaction.abort();&#10;        return vec;&#10;    }&#10;}&#10;&#10;&#10;std::string Fetch::FetchTemplates() const {&#10;    std::clog &lt;&lt; &quot;[Fetch::FetchTemplates] Fetching template from database&quot; &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    const std::string query = R&quot;(SELECT template_texto FROM templates_anas WHERE is_active = true LIMIT 1;)&quot;;&#10;    try {&#10;        const auto result = transaction.exec(pqxx::zview(query));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchTemplates] Query returned &quot; &lt;&lt; result.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        transaction.commit();&#10;        return result[0][0].as&lt;std::string&gt;();&#10;    } catch (const pqxx::sql_error&amp; e) {&#10;        std::clog &lt;&lt; &quot;SQL error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;}&#10;&#10;&#10;const std::vector&lt;Instance&gt; Fetch::FetchInstances() const {&#10;    std::clog &lt;&lt; &quot;[Fetch::FetchInstances] Fetching instances from database&quot; &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    std::vector&lt;Instance&gt; vec;&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return vec;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    const std::string query = &quot;SELECT connection_name, connection_number, connection_token, daily_limit, sent_today FROM parametros_disparos WHERE is_active = true AND is_banned = false AND sent_today &lt; daily_limit&quot;;&#10;    try {&#10;        auto res = transaction.exec(pqxx::zview(query));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchInstances] Query returned &quot; &lt;&lt; res.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        for (auto row: res) {&#10;            Instance inst;&#10;            inst.InstanceName = row[0].as&lt;std::string&gt;();&#10;            inst.InstanceNumber = row[1].as&lt;std::string&gt;();&#10;            inst.Token = row[2].as&lt;std::string&gt;();&#10;            inst.DailyLimit = row[3].as&lt;int&gt;();&#10;            inst.SentToday = row[4].as&lt;int&gt;();&#10;            std::clog &lt;&lt; &quot;[Fetch::FetchInstances] Instance: &quot; &lt;&lt; inst.InstanceNumber &lt;&lt; &quot;, SentToday: &quot; &lt;&lt; inst.SentToday &lt;&lt; &quot;, DailyLimit: &quot; &lt;&lt; inst.DailyLimit &lt;&lt; std::endl;&#10;            vec.push_back(inst);&#10;        }&#10;        return vec;&#10;    } catch (const pqxx::sql_error&amp; e) {&#10;        std::clog &lt;&lt; &quot;SQL error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return vec;&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return vec;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>