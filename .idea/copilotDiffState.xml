<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/include/Database/Insert.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/Database/Insert.h" />
              <option name="originalContent" value="#ifndef INCLUDE_DATABASE_INSERT_H&#10;#define INCLUDE_DATABASE_INSERT_H&#10;&#10;#include &quot;Database.h&quot;&#10;#include &quot;Models.h&quot;&#10;&#10;class Insert {&#10;private:&#10;    std::unique_ptr&lt;Database&gt; ownedDb;&#10;    Database *db;&#10;public:&#10;    explicit Insert(Database&amp; db) : db(&amp;db) {}&#10;    explicit Insert(const std::string&amp; Url) : ownedDb(std::make_unique&lt;Database&gt;(Url)), db(ownedDb.get()) {}&#10;    void InsertLog(Message* msg) const;&#10;    void InsertTrafegoLog(Trafego* trafego) const;&#10;    void UpdateProcessado(const std::string&amp; telefone) const;&#10;    void UpdateTabela(const std::string&amp; telefone) const;&#10;    void SetBanned(const std::string&amp; telefone) const;&#10;};&#10;&#10;#endif //INCLUDE_DATABASE_INSERT_H" />
              <option name="updatedContent" value="#ifndef INCLUDE_DATABASE_INSERT_H&#10;#define INCLUDE_DATABASE_INSERT_H&#10;&#10;#include &quot;Database.h&quot;&#10;#include &quot;Models.h&quot;&#10;&#10;class Insert {&#10;private:&#10;    std::unique_ptr&lt;Database&gt; ownedDb;&#10;    Database *db;&#10;public:&#10;    explicit Insert(Database&amp; db) : db(&amp;db) {}&#10;    explicit Insert(const std::string&amp; Url) : ownedDb(std::make_unique&lt;Database&gt;(Url)), db(ownedDb.get()) {}&#10;    void InsertLog(Message* msg) const;&#10;    void InsertTrafegoLog(Trafego* trafego) const;&#10;    void UpdateProcessado(const std::string&amp; telefone) const;&#10;    void UpdateTabela(const std::string&amp; telefone) const;&#10;    void SetBanned(const std::string&amp; telefone) const;&#10;    void InsertInstance(const Instance_t&amp; instance) const;&#10;};&#10;&#10;#endif //INCLUDE_DATABASE_INSERT_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Api.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Api.cpp" />
              <option name="originalContent" value="#include &quot;../include/Api/Api.h&quot;&#10;#include &lt;curl/curl.h&gt;&#10;#include &quot;../third_party/json.h&quot;&#10;#include &lt;format&gt;&#10;#include &lt;iostream&gt;&#10;&#10;size_t Api::WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {&#10;    size_t totalSize = size * nmemb;&#10;    auto* resp = static_cast&lt;std::string*&gt;(userp);&#10;    resp-&gt;append(static_cast&lt;char*&gt;(contents), totalSize);&#10;    return totalSize;&#10;}&#10;&#10;bool Api::SendMessageApi(Request *req) {&#10;    std::clog &lt;&lt; &quot;[Api::SendMessageApi] Called with number: &quot; &lt;&lt; req-&gt;Number &lt;&lt; &quot;, body: &quot; &lt;&lt; req-&gt;Body &lt;&lt; std::endl;&#10;    const std::string url = &quot;https://bk.atendimento-meuconsig.com.br/api/messages/send&quot;;&#10;    CURL* curl = curl_easy_init();&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return false;&#10;    }&#10;    nlohmann::json req_body = {&#10;        {&quot;number&quot;, req-&gt;Number},&#10;        {&quot;body&quot;, req-&gt;Body},&#10;        {&quot;queueId&quot;, 2},&#10;        {&quot;sendSignature&quot;, false},&#10;        {&quot;closeTicket&quot;, true},&#10;        {&quot;userId&quot;, &quot;&quot;}&#10;    };&#10;    std::string str_bod = req_body.dump();&#10;    struct curl_slist* headers = nullptr;&#10;    const std::string auth = std::format(&quot;Authorization: {}&quot;, req-&gt;ApiKey);&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/json&quot;);&#10;    headers = curl_slist_append(headers, auth.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, str_bod.c_str());&#10;    std::clog &lt;&lt; &quot;[Api::SendMessageApi] Sending POST to: &quot; &lt;&lt; url &lt;&lt; std::endl;&#10;    CURLcode res = curl_easy_perform(curl);&#10;    long http_code = 0;&#10;    if (res == CURLE_OK) {&#10;        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;http_code);&#10;        std::clog &lt;&lt; &quot;[Api::SendMessageApi] HTTP code: &quot; &lt;&lt; http_code &lt;&lt; std::endl;&#10;    } else {&#10;        std::clog &lt;&lt; &quot;ERROR: curl_easy_perform failed: &quot; &lt;&lt; curl_easy_strerror(res) &lt;&lt; &quot;\n&quot;;&#10;    }&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    std::clog &lt;&lt; &quot;[Api::SendMessageApi] Finished with status: &quot; &lt;&lt; (res == CURLE_OK &amp;&amp; http_code &gt;= 200 &amp;&amp; http_code &lt; 300) &lt;&lt; std::endl;&#10;    return (res == CURLE_OK &amp;&amp; http_code &gt;= 200 &amp;&amp; http_code &lt; 300);&#10;}&#10;&#10;std::string Api::Login(const std::string &amp;email, const std::string &amp;password) {&#10;    std::clog &lt;&lt; &quot;[Api::Login] Called with email: &quot; &lt;&lt; email &lt;&lt; std::endl;&#10;    const std::string url = &quot;https://bk.atendimento-meuconsig.com.br/auth/login&quot;;&#10;    CURL* curl = curl_easy_init();&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;    nlohmann::json req_body = {&#10;        {&quot;email&quot;, email},&#10;        {&quot;password&quot;, password}&#10;    };&#10;    std::string respBody;&#10;    std::string str_bod = req_body.dump();&#10;    struct curl_slist* headers = nullptr;&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/json&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, str_bod.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBody);&#10;    std::clog &lt;&lt; &quot;[Api::Login] Sending POST to: &quot; &lt;&lt; url &lt;&lt; std::endl;&#10;    CURLcode res = curl_easy_perform(curl);&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    if (res != CURLE_OK) {&#10;        std::clog &lt;&lt; &quot;ERROR: curl_easy_perform failed: &quot; &lt;&lt; curl_easy_strerror(res) &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;    try {&#10;        auto json_resp = nlohmann::json::parse(respBody);&#10;        if (json_resp.contains(&quot;token&quot;)) {&#10;            std::clog &lt;&lt; &quot;[Api::Login] Login successful, token received.&quot; &lt;&lt; std::endl;&#10;            return json_resp[&quot;token&quot;].get&lt;std::string&gt;();&#10;        } else {&#10;            std::clog &lt;&lt; &quot;ERROR: No token in response\n&quot;;&#10;            return &quot;&quot;;&#10;        }&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to parse JSON: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;}&#10;&#10;std::vector&lt;Instance_t&gt; Api::GetConnections(const std::string &amp;email, const std::string &amp;password) {&#10;    std::clog &lt;&lt; &quot;[Api::GetConnections] Called with email: &quot; &lt;&lt; email &lt;&lt; std::endl;&#10;    const std::string url = &quot;https://bk.atendimento-meuconsig.com.br/whatsapp?companyId=2&amp;session=0&quot;;&#10;    const std::string token = Login(email, password);&#10;    std::string respBody;&#10;    CURL* curl = curl_easy_init();&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return {};&#10;    }&#10;    struct curl_slist* headers = nullptr;&#10;    const std::string auth = std::format(&quot;Authorization: Bearer {}&quot;, token);&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/json&quot;);&#10;    headers = curl_slist_append(headers, auth.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;GET&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBody);&#10;    std::clog &lt;&lt; &quot;[Api::GetConnections] Sending GET to: &quot; &lt;&lt; url &lt;&lt; std::endl;&#10;    CURLcode res = curl_easy_perform(curl);&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    if (res != CURLE_OK) {&#10;        std::clog &lt;&lt; &quot;ERROR: curl_easy_perform failed: &quot; &lt;&lt; curl_easy_strerror(res) &lt;&lt; &quot;\n&quot;;&#10;        return {};&#10;    }&#10;    std::vector&lt;Instance_t&gt; instances;&#10;    try {&#10;        auto json_resp = nlohmann::json::parse(respBody);&#10;        if (!json_resp.is_array()) {&#10;            std::clog &lt;&lt; &quot;ERROR: Expected array of connections in JSON\n&quot;;&#10;            return {};&#10;        }&#10;        for (const auto&amp; item : json_resp) {&#10;            Instance_t inst;&#10;            inst.Id = item.value(&quot;id&quot;, 0);&#10;            inst.InstanceName = item.value(&quot;name&quot;, &quot;&quot;);&#10;            inst.InstanceNumber = item.value(&quot;number&quot;, &quot;&quot;);&#10;            inst.Status = item.value(&quot;status&quot;, &quot;&quot;) == &quot;CONNECTED&quot;;&#10;            std::clog &lt;&lt; &quot;[Api::GetConnections] Instance: &quot; &lt;&lt; inst.InstanceName &lt;&lt; &quot;, Number: &quot; &lt;&lt; inst.InstanceNumber &lt;&lt; &quot;, Status: &quot; &lt;&lt; inst.Status &lt;&lt; std::endl;&#10;            instances.push_back(inst);&#10;        }&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to parse JSON: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return {};&#10;    }&#10;    std::clog &lt;&lt; &quot;[Api::GetConnections] Returning &quot; &lt;&lt; instances.size() &lt;&lt; &quot; instances.&quot; &lt;&lt; std::endl;&#10;    return instances;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/Api/Api.h&quot;&#10;#include &lt;curl/curl.h&gt;&#10;#include &quot;../third_party/json.h&quot;&#10;#include &lt;format&gt;&#10;#include &lt;iostream&gt;&#10;&#10;size_t Api::WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {&#10;    size_t totalSize = size * nmemb;&#10;    auto* resp = static_cast&lt;std::string*&gt;(userp);&#10;    resp-&gt;append(static_cast&lt;char*&gt;(contents), totalSize);&#10;    return totalSize;&#10;}&#10;&#10;bool Api::SendMessageApi(Request *req) {&#10;    std::clog &lt;&lt; &quot;[Api::SendMessageApi] Called with number: &quot; &lt;&lt; req-&gt;Number &lt;&lt; &quot;, body: &quot; &lt;&lt; req-&gt;Body &lt;&lt; std::endl;&#10;    const std::string url = &quot;https://bk.atendimento-meuconsig.com.br/api/messages/send&quot;;&#10;    CURL* curl = curl_easy_init();&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return false;&#10;    }&#10;    nlohmann::json req_body = {&#10;        {&quot;number&quot;, req-&gt;Number},&#10;        {&quot;body&quot;, req-&gt;Body},&#10;        {&quot;queueId&quot;, 2},&#10;        {&quot;sendSignature&quot;, false},&#10;        {&quot;closeTicket&quot;, true},&#10;        {&quot;userId&quot;, &quot;&quot;}&#10;    };&#10;    std::string str_bod = req_body.dump();&#10;    struct curl_slist* headers = nullptr;&#10;    const std::string auth = std::format(&quot;Authorization: {}&quot;, req-&gt;ApiKey);&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/json&quot;);&#10;    headers = curl_slist_append(headers, auth.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, str_bod.c_str());&#10;    std::clog &lt;&lt; &quot;[Api::SendMessageApi] Sending POST to: &quot; &lt;&lt; url &lt;&lt; std::endl;&#10;    CURLcode res = curl_easy_perform(curl);&#10;    long http_code = 0;&#10;    if (res == CURLE_OK) {&#10;        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;http_code);&#10;        std::clog &lt;&lt; &quot;[Api::SendMessageApi] HTTP code: &quot; &lt;&lt; http_code &lt;&lt; std::endl;&#10;    } else {&#10;        std::clog &lt;&lt; &quot;ERROR: curl_easy_perform failed: &quot; &lt;&lt; curl_easy_strerror(res) &lt;&lt; &quot;\n&quot;;&#10;    }&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    std::clog &lt;&lt; &quot;[Api::SendMessageApi] Finished with status: &quot; &lt;&lt; (res == CURLE_OK &amp;&amp; http_code &gt;= 200 &amp;&amp; http_code &lt; 300) &lt;&lt; std::endl;&#10;    return (res == CURLE_OK &amp;&amp; http_code &gt;= 200 &amp;&amp; http_code &lt; 300);&#10;}&#10;&#10;std::string Api::Login(const std::string &amp;email, const std::string &amp;password) {&#10;    std::clog &lt;&lt; &quot;[Api::Login] Called with email: &quot; &lt;&lt; email &lt;&lt; std::endl;&#10;    const std::string url = &quot;https://bk.atendimento-meuconsig.com.br/auth/login&quot;;&#10;    CURL* curl = curl_easy_init();&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;    nlohmann::json req_body = {&#10;        {&quot;email&quot;, email},&#10;        {&quot;password&quot;, password}&#10;    };&#10;    std::string respBody;&#10;    std::string str_bod = req_body.dump();&#10;    struct curl_slist* headers = nullptr;&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/json&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, str_bod.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBody);&#10;    std::clog &lt;&lt; &quot;[Api::Login] Sending POST to: &quot; &lt;&lt; url &lt;&lt; std::endl;&#10;    CURLcode res = curl_easy_perform(curl);&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    if (res != CURLE_OK) {&#10;        std::clog &lt;&lt; &quot;ERROR: curl_easy_perform failed: &quot; &lt;&lt; curl_easy_strerror(res) &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;    std::clog &lt;&lt; &quot;[Api::Login] Raw response: &quot; &lt;&lt; respBody &lt;&lt; std::endl;&#10;    try {&#10;        auto json_resp = nlohmann::json::parse(respBody);&#10;        if (json_resp.contains(&quot;token&quot;)) {&#10;            std::clog &lt;&lt; &quot;[Api::Login] Login successful, token received.&quot; &lt;&lt; std::endl;&#10;            return json_resp[&quot;token&quot;].get&lt;std::string&gt;();&#10;        } else {&#10;            std::clog &lt;&lt; &quot;ERROR: No token in response\n&quot;;&#10;            return &quot;&quot;;&#10;        }&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to parse JSON: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;}&#10;&#10;std::vector&lt;Instance_t&gt; Api::GetConnections(const std::string &amp;email, const std::string &amp;password) {&#10;    std::clog &lt;&lt; &quot;[Api::GetConnections] Called with email: &quot; &lt;&lt; email &lt;&lt; std::endl;&#10;    const std::string url = &quot;https://bk.atendimento-meuconsig.com.br/whatsapp?companyId=2&amp;session=0&quot;;&#10;    const std::string token = Login(email, password);&#10;    std::string respBody;&#10;    CURL* curl = curl_easy_init();&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return {};&#10;    }&#10;    struct curl_slist* headers = nullptr;&#10;    const std::string auth = std::format(&quot;Authorization: Bearer {}&quot;, token);&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/json&quot;);&#10;    headers = curl_slist_append(headers, auth.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;GET&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBody);&#10;    std::clog &lt;&lt; &quot;[Api::GetConnections] Sending GET to: &quot; &lt;&lt; url &lt;&lt; std::endl;&#10;    CURLcode res = curl_easy_perform(curl);&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    if (res != CURLE_OK) {&#10;        std::clog &lt;&lt; &quot;ERROR: curl_easy_perform failed: &quot; &lt;&lt; curl_easy_strerror(res) &lt;&lt; &quot;\n&quot;;&#10;        return {};&#10;    }&#10;    std::vector&lt;Instance_t&gt; instances;&#10;    try {&#10;        auto json_resp = nlohmann::json::parse(respBody);&#10;        if (!json_resp.is_array()) {&#10;            std::clog &lt;&lt; &quot;ERROR: Expected array of connections in JSON\n&quot;;&#10;            return {};&#10;        }&#10;        for (const auto&amp; item : json_resp) {&#10;            Instance_t inst;&#10;            inst.Id = item.value(&quot;id&quot;, 0);&#10;            inst.InstanceName = item.value(&quot;name&quot;, &quot;&quot;);&#10;            inst.InstanceNumber = item.value(&quot;number&quot;, &quot;&quot;);&#10;            inst.Status = item.value(&quot;status&quot;, &quot;&quot;) == &quot;CONNECTED&quot;;&#10;            std::clog &lt;&lt; &quot;[Api::GetConnections] Instance: &quot; &lt;&lt; inst.InstanceName &lt;&lt; &quot;, Number: &quot; &lt;&lt; inst.InstanceNumber &lt;&lt; &quot;, Status: &quot; &lt;&lt; inst.Status &lt;&lt; std::endl;&#10;            instances.push_back(inst);&#10;        }&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to parse JSON: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return {};&#10;    }&#10;    std::clog &lt;&lt; &quot;[Api::GetConnections] Returning &quot; &lt;&lt; instances.size() &lt;&lt; &quot; instances.&quot; &lt;&lt; std::endl;&#10;    return instances;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Config.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Config.cpp" />
              <option name="originalContent" value="#include &quot;../include/Config.h&quot;&#10;#include &quot;../third_party/dotenv.h&quot;&#10;#include &lt;memory&gt;&#10;&#10;Config::Config() : env(std::make_unique&lt;Env&gt;()){&#10;    const std::string root_path = &quot;../.env&quot;;&#10;    dotenv::init(root_path.c_str());&#10;}&#10;&#10;const Config::Env &amp;Config::GetEnv() const {&#10;    env-&gt;DbUrl = dotenv::getenv(&quot;DB_URL&quot;);&#10;    env-&gt;DbUrlTrafego = dotenv::getenv(&quot;DB_URL_TRAFEGO&quot;);&#10;    env-&gt;DbUrlV3 = dotenv::getenv(&quot;DB_URL_V3&quot;);&#10;    env-&gt;LoginArca = dotenv::getenv(&quot;LOGIN_ARCA&quot;);&#10;    env-&gt;PasswordArca = dotenv::getenv(&quot;PASSWORD_ARCA&quot;);&#10;&#10;    return *env;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/Config.h&quot;&#13;&#10;#include &quot;../third_party/dotenv.h&quot;&#13;&#10;#include &lt;memory&gt;&#13;&#10;#include &lt;iostream&gt;&#13;&#10;&#13;&#10;Config::Config() : env(std::make_unique&lt;Env&gt;()){&#13;&#10;    std::clog &lt;&lt; &quot;[Config::Config] Initializing dotenv with ../.env&quot; &lt;&lt; std::endl;&#13;&#10;    const std::string root_path = &quot;../.env&quot;;&#13;&#10;    dotenv::init(root_path.c_str());&#13;&#10;}&#13;&#10;&#13;&#10;const Config::Env &amp;Config::GetEnv() const {&#13;&#10;    std::clog &lt;&lt; &quot;[Config::GetEnv] Loading environment variables&quot; &lt;&lt; std::endl;&#13;&#10;    env-&gt;DbUrl = dotenv::getenv(&quot;DB_URL&quot;);&#13;&#10;    env-&gt;DbUrlTrafego = dotenv::getenv(&quot;DB_URL_TRAFEGO&quot;);&#13;&#10;    env-&gt;DbUrlV3 = dotenv::getenv(&quot;DB_URL_V3&quot;);&#13;&#10;    env-&gt;LoginArca = dotenv::getenv(&quot;LOGIN_ARCA&quot;);&#13;&#10;    env-&gt;PasswordArca = dotenv::getenv(&quot;PASSWORD_ARCA&quot;);&#13;&#10;    std::clog &lt;&lt; &quot;[Config::GetEnv] DB_URL: &quot; &lt;&lt; env-&gt;DbUrl &lt;&lt; std::endl;&#13;&#10;    std::clog &lt;&lt; &quot;[Config::GetEnv] DB_URL_TRAFEGO: &quot; &lt;&lt; env-&gt;DbUrlTrafego &lt;&lt; std::endl;&#13;&#10;    std::clog &lt;&lt; &quot;[Config::GetEnv] DB_URL_V3: &quot; &lt;&lt; env-&gt;DbUrlV3 &lt;&lt; std::endl;&#13;&#10;    std::clog &lt;&lt; &quot;[Config::GetEnv] LOGIN_ARCA: &quot; &lt;&lt; env-&gt;LoginArca &lt;&lt; std::endl;&#13;&#10;    // Do not log password for security&#13;&#10;    return *env;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Database/Fetch.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Database/Fetch.cpp" />
              <option name="originalContent" value="#include &quot;../../include/Database/Fetch.h&quot;&#10;&#10;#include &lt;iostream&gt;&#10;&#10;std::vector&lt;EntradaClt&gt; Fetch::FetchBolsa() {&#10;    std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Fetching Bolsa leads from database&quot; &lt;&lt; std::endl;&#10;    std::vector&lt;EntradaClt&gt; vec;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return vec;&#10;    }&#10;&#10;    pqxx::work transaction(*c);&#10;    const std::string query = R&quot;(SELECT DISTINCT ON (telefone)&#10;&#9;&#9;carteira_assinada, tempo_emprego, valor_desejado, nome, cpf, telefone, tag, produto, processado&#10;&#9;&#9;FROM entrada_clt&#10;&#9;&#9;WHERE processado = FALSE AND produto = 'bolsa-familia'&#10;&#9;&#9;AND tag != 'base'&#10;&#9;&#9;ORDER BY telefone, random()&#10;&#9;&#9;LIMIT 45;)&quot;;&#10;    try {&#10;        auto result = transaction.exec(pqxx::zview(query));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Query 1 returned &quot; &lt;&lt; result.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        if (!result.empty()) {&#10;            for (auto row: result) {&#10;                EntradaClt e;&#10;                e.CarteiraAssinada = row[0].as&lt;std::string&gt;();&#10;                e.TempoEmprego = row[1].as&lt;std::string&gt;();&#10;                e.ValorDesejado = row[2].as&lt;std::string&gt;();&#10;                e.Nome = row[3].as&lt;std::string&gt;();&#10;                e.Cpf = row[4].as&lt;std::string&gt;();&#10;                e.Telefone = row[5].as&lt;std::string&gt;();&#10;                e.Tag = row[6].as&lt;std::string&gt;();&#10;                e.Produto = row[7].as&lt;std::string&gt;();&#10;                e.Processado = row[8].as&lt;std::string&gt;();&#10;                std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Lead: &quot; &lt;&lt; e.Telefone &lt;&lt; &quot;, Tag: &quot; &lt;&lt; e.Tag &lt;&lt; std::endl;&#10;                vec.push_back(e);&#10;            }&#10;            return vec;&#10;        }&#10;        auto res2 = transaction.exec(pqxx::zview(R&quot;(SELECT DISTINCT ON (telefone)&#10;&#9;&#9;&#9;carteira_assinada, tempo_emprego, valor_desejado, nome, cpf, telefone, tag, produto, processado&#10;&#9;&#9;&#9;FROM entrada_clt&#10;&#9;&#9;&#9;WHERE processado = FALSE AND produto = 'bolsa-familia'&#10;&#9;&#9;&#9;AND tag = 'base'&#10;&#9;&#9;&#9;AND status_cref-&gt;'costumer_data'-&gt;&gt;'erro' = 'false'&#10;&#9;&#9;&#9;AND status_cref-&gt;'costumer_data'-&gt;'objeto'-&gt;&gt;'permiteCaptura' = 'true'&#10;&#9;&#9;&#9;AND status_cref-&gt;'costumer_data'-&gt;'objeto'-&gt;&gt;'mensagem' = 'Prosseguir com simulação'&#10;&#9;&#9;&#9;ORDER BY telefone, random()&#10;&#9;&#9;&#9;LIMIT 45;)&quot;));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Query 2 returned &quot; &lt;&lt; res2.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        if (!res2.empty()) {&#10;            for (auto row: result) {&#10;                EntradaClt e;&#10;                e.CarteiraAssinada = row[0].as&lt;std::string&gt;();&#10;                e.TempoEmprego = row[1].as&lt;std::string&gt;();&#10;                e.ValorDesejado = row[2].as&lt;std::string&gt;();&#10;                e.Nome = row[3].as&lt;std::string&gt;();&#10;                e.Cpf = row[4].as&lt;std::string&gt;();&#10;                e.Telefone = row[5].as&lt;std::string&gt;();&#10;                e.Tag = row[6].as&lt;std::string&gt;();&#10;                e.Produto = row[7].as&lt;std::string&gt;();&#10;                e.Processado = row[8].as&lt;std::string&gt;();&#10;                std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Lead: &quot; &lt;&lt; e.Telefone &lt;&lt; &quot;, Tag: &quot; &lt;&lt; e.Tag &lt;&lt; std::endl;&#10;                vec.push_back(e);&#10;            }&#10;            return vec;&#10;        }&#10;        return vec;&#10;    } catch (pqxx::sql_error const &amp;e) {&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] SQL error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        transaction.abort();&#10;        return vec;&#10;    }&#10;}&#10;&#10;&#10;std::string Fetch::FetchTemplates() const {&#10;    std::clog &lt;&lt; &quot;[Fetch::FetchTemplates] Fetching template from database&quot; &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    const std::string query = R&quot;(SELECT template_texto FROM templates_anas WHERE is_active = true LIMIT 1;)&quot;;&#10;    try {&#10;        const auto result = transaction.exec(pqxx::zview(query));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchTemplates] Query returned &quot; &lt;&lt; result.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        transaction.commit();&#10;        return result[0][0].as&lt;std::string&gt;();&#10;    } catch (const pqxx::sql_error&amp; e) {&#10;        std::clog &lt;&lt; &quot;SQL error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;}&#10;&#10;&#10;const std::vector&lt;Instance&gt; Fetch::FetchInstances() const {&#10;    std::clog &lt;&lt; &quot;[Fetch::FetchInstances] Fetching instances from database&quot; &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    std::vector&lt;Instance&gt; vec;&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return vec;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    const std::string query = &quot;SELECT connection_name, connection_number, connection_token, daily_limit, sent_today FROM parametros_disparos WHERE is_active = true AND is_banned = false AND sent_today &lt; daily_limit&quot;;&#10;    try {&#10;        auto res = transaction.exec(pqxx::zview(query));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchInstances] Query returned &quot; &lt;&lt; res.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        for (auto row: res) {&#10;            Instance inst;&#10;            inst.InstanceName = row[0].as&lt;std::string&gt;();&#10;            inst.InstanceNumber = row[1].as&lt;std::string&gt;();&#10;            inst.Token = row[2].as&lt;std::string&gt;();&#10;            inst.DailyLimit = row[3].as&lt;int&gt;();&#10;            inst.SentToday = row[4].as&lt;int&gt;();&#10;            std::clog &lt;&lt; &quot;[Fetch::FetchInstances] Instance: &quot; &lt;&lt; inst.InstanceNumber &lt;&lt; &quot;, SentToday: &quot; &lt;&lt; inst.SentToday &lt;&lt; &quot;, DailyLimit: &quot; &lt;&lt; inst.DailyLimit &lt;&lt; std::endl;&#10;            vec.push_back(inst);&#10;        }&#10;        return vec;&#10;    } catch (const pqxx::sql_error&amp; e) {&#10;        std::clog &lt;&lt; &quot;SQL error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return vec;&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return vec;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../../include/Database/Fetch.h&quot;&#10;&#10;#include &lt;iostream&gt;&#10;&#10;std::vector&lt;EntradaClt&gt; Fetch::FetchBolsa() {&#10;    std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Fetching Bolsa leads from database&quot; &lt;&lt; std::endl;&#10;    std::vector&lt;EntradaClt&gt; vec;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return vec;&#10;    }&#10;&#10;    pqxx::work transaction(*c);&#10;    const std::string query = R&quot;(SELECT DISTINCT ON (telefone)&#10;&#9;&#9;carteira_assinada, tempo_emprego, valor_desejado, nome, cpf, telefone, tag, produto, processado&#10;&#9;&#9;FROM entrada_clt&#10;&#9;&#9;WHERE processado = FALSE AND produto = 'bolsa-familia'&#10;&#9;&#9;AND tag != 'base'&#10;&#9;&#9;ORDER BY telefone, random()&#10;&#9;&#9;LIMIT 45;)&quot;;&#10;    try {&#10;        auto result = transaction.exec(pqxx::zview(query));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Query 1 returned &quot; &lt;&lt; result.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        if (!result.empty()) {&#10;            for (auto row: result) {&#10;                EntradaClt e;&#10;                e.CarteiraAssinada = row[0].is_null() ? &quot;&quot; : row[0].as&lt;std::string&gt;();&#10;                e.TempoEmprego = row[1].is_null() ? &quot;&quot; : row[1].as&lt;std::string&gt;();&#10;                e.ValorDesejado = row[2].is_null() ? &quot;&quot; : row[2].as&lt;std::string&gt;();&#10;                e.Nome = row[3].is_null() ? &quot;&quot; : row[3].as&lt;std::string&gt;();&#10;                e.Cpf = row[4].is_null() ? &quot;&quot; : row[4].as&lt;std::string&gt;();&#10;                e.Telefone = row[5].is_null() ? &quot;&quot; : row[5].as&lt;std::string&gt;();&#10;                e.Tag = row[6].is_null() ? &quot;&quot; : row[6].as&lt;std::string&gt;();&#10;                e.Produto = row[7].is_null() ? &quot;&quot; : row[7].as&lt;std::string&gt;();&#10;                e.Processado = row[8].is_null() ? &quot;&quot; : row[8].as&lt;std::string&gt;();&#10;                std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Lead: &quot; &lt;&lt; e.Telefone &lt;&lt; &quot;, Tag: &quot; &lt;&lt; e.Tag &lt;&lt; std::endl;&#10;                vec.push_back(e);&#10;            }&#10;            return vec;&#10;        }&#10;        auto res2 = transaction.exec(pqxx::zview(R&quot;(SELECT DISTINCT ON (telefone)&#10;&#9;&#9;&#9;carteira_assinada, tempo_emprego, valor_desejado, nome, cpf, telefone, tag, produto, processado&#10;&#9;&#9;&#9;FROM entrada_clt&#10;&#9;&#9;&#9;WHERE processado = FALSE AND produto = 'bolsa-familia'&#10;&#9;&#9;&#9;AND tag = 'base'&#10;&#9;&#9;&#9;AND status_cref-&gt;'costumer_data'-&gt;&gt;'erro' = 'false'&#10;&#9;&#9;&#9;AND status_cref-&gt;'costumer_data'-&gt;'objeto'-&gt;&gt;'permiteCaptura' = 'true'&#10;&#9;&#9;&#9;AND status_cref-&gt;'costumer_data'-&gt;'objeto'-&gt;&gt;'mensagem' = 'Prosseguir com simulação'&#10;&#9;&#9;&#9;ORDER BY telefone, random()&#10;&#9;&#9;&#9;LIMIT 45;)&quot;));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Query 2 returned &quot; &lt;&lt; res2.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        if (!res2.empty()) {&#10;            for (auto row: res2) {&#10;                EntradaClt e;&#10;                e.CarteiraAssinada = row[0].is_null() ? &quot;&quot; : row[0].as&lt;std::string&gt;();&#10;                e.TempoEmprego = row[1].is_null() ? &quot;&quot; : row[1].as&lt;std::string&gt;();&#10;                e.ValorDesejado = row[2].is_null() ? &quot;&quot; : row[2].as&lt;std::string&gt;();&#10;                e.Nome = row[3].is_null() ? &quot;&quot; : row[3].as&lt;std::string&gt;();&#10;                e.Cpf = row[4].is_null() ? &quot;&quot; : row[4].as&lt;std::string&gt;();&#10;                e.Telefone = row[5].is_null() ? &quot;&quot; : row[5].as&lt;std::string&gt;();&#10;                e.Tag = row[6].is_null() ? &quot;&quot; : row[6].as&lt;std::string&gt;();&#10;                e.Produto = row[7].is_null() ? &quot;&quot; : row[7].as&lt;std::string&gt;();&#10;                e.Processado = row[8].is_null() ? &quot;&quot; : row[8].as&lt;std::string&gt;();&#10;                std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] Lead: &quot; &lt;&lt; e.Telefone &lt;&lt; &quot;, Tag: &quot; &lt;&lt; e.Tag &lt;&lt; std::endl;&#10;                vec.push_back(e);&#10;            }&#10;            return vec;&#10;        }&#10;        return vec;&#10;    } catch (pqxx::sql_error const &amp;e) {&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchBolsa] SQL error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        transaction.abort();&#10;        return vec;&#10;    }&#10;}&#10;&#10;&#10;std::string Fetch::FetchTemplates() const {&#10;    std::clog &lt;&lt; &quot;[Fetch::FetchTemplates] Fetching template from database&quot; &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    const std::string query = R&quot;(SELECT template_texto FROM templates_anas WHERE is_active = true LIMIT 1;)&quot;;&#10;    try {&#10;        const auto result = transaction.exec(pqxx::zview(query));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchTemplates] Query returned &quot; &lt;&lt; result.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        transaction.commit();&#10;        return result[0][0].as&lt;std::string&gt;();&#10;    } catch (const pqxx::sql_error&amp; e) {&#10;        std::clog &lt;&lt; &quot;SQL error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;}&#10;&#10;&#10;const std::vector&lt;Instance&gt; Fetch::FetchInstances() const {&#10;    std::clog &lt;&lt; &quot;[Fetch::FetchInstances] Fetching instances from database&quot; &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    std::vector&lt;Instance&gt; vec;&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return vec;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    const std::string query = &quot;SELECT connection_name, connection_number, connection_token, daily_limit, sent_today FROM parametros_disparos WHERE is_active = true AND is_banned = false AND sent_today &lt; daily_limit&quot;;&#10;    try {&#10;        auto res = transaction.exec(pqxx::zview(query));&#10;        std::clog &lt;&lt; &quot;[Fetch::FetchInstances] Query returned &quot; &lt;&lt; res.size() &lt;&lt; &quot; rows&quot; &lt;&lt; std::endl;&#10;        for (auto row: res) {&#10;            Instance inst;&#10;            inst.InstanceName = row[0].as&lt;std::string&gt;();&#10;            inst.InstanceNumber = row[1].as&lt;std::string&gt;();&#10;            inst.Token = row[2].as&lt;std::string&gt;();&#10;            inst.DailyLimit = row[3].as&lt;int&gt;();&#10;            inst.SentToday = row[4].as&lt;int&gt;();&#10;            std::clog &lt;&lt; &quot;[Fetch::FetchInstances] Instance: &quot; &lt;&lt; inst.InstanceNumber &lt;&lt; &quot;, SentToday: &quot; &lt;&lt; inst.SentToday &lt;&lt; &quot;, DailyLimit: &quot; &lt;&lt; inst.DailyLimit &lt;&lt; std::endl;&#10;            vec.push_back(inst);&#10;        }&#10;        return vec;&#10;    } catch (const pqxx::sql_error&amp; e) {&#10;        std::clog &lt;&lt; &quot;SQL error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return vec;&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return vec;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Database/Insert.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Database/Insert.cpp" />
              <option name="originalContent" value="#include &quot;../../include/Database/Insert.h&quot;&#10;&#10;#include &lt;iostream&gt;&#10;&#10;void Insert::InsertLog(Message *msg) const {&#10;    std::clog &lt;&lt; &quot;[Insert::InsertLog] Inserting log for destino: &quot; &lt;&lt; msg-&gt;Destino &lt;&lt; &quot;, status: &quot; &lt;&lt; msg-&gt;Status &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        pqxx::result res = transaction.exec(pqxx::zview(&quot;INSERT INTO logs_disparo (source, source_name, destino, status, template) VALUES ($1, $2, $3, $4, $5)&quot;), pqxx::params(msg-&gt;Source, msg-&gt;SourceName, msg-&gt;Destino, msg-&gt;Status, msg-&gt;Template));&#10;        if (!res.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;[Insert::InsertLog][ERROR] No rows inserted for destino: &quot; &lt;&lt; msg-&gt;Destino &lt;&lt; &quot;, status: &quot; &lt;&lt; msg-&gt;Status &lt;&lt; std::endl;&#10;        } else {&#10;            std::clog &lt;&lt; &quot;[Insert::InsertLog][SUCCESS] Log inserted for destino: &quot; &lt;&lt; msg-&gt;Destino &lt;&lt; &quot;, status: &quot; &lt;&lt; msg-&gt;Status &lt;&lt; std::endl;&#10;        }&#10;    }catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        std::clog &lt;&lt; &quot;[Insert::InsertLog][DB ERROR] &quot; &lt;&lt; e.what() &lt;&lt; &quot; for destino: &quot; &lt;&lt; msg-&gt;Destino &lt;&lt; &quot;, status: &quot; &lt;&lt; msg-&gt;Status &lt;&lt; std::endl;&#10;        return;&#10;    }&#10;    transaction.commit();&#10;    std::clog &lt;&lt; &quot;[Insert::InsertLog] Log inserted for destino: &quot; &lt;&lt; msg-&gt;Destino &lt;&lt; std::endl;&#10;}&#10;&#10;void Insert::InsertTrafegoLog(Trafego *trafego) const {&#10;    std::clog &lt;&lt; &quot;[Insert::InsertTrafegoLog] Inserting trafego log for phone: &quot; &lt;&lt; trafego-&gt;Phone &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        pqxx::result res = transaction.exec(pqxx::zview(&quot;INSERT INTO logstrafegohuggy (name, phone, tag, timestamp) VALUES ($1, $2, $3, NOW())&quot;), pqxx::params(trafego-&gt;Name, trafego-&gt;Phone, trafego-&gt;Tag));&#10;        if (!res.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Trafego Logs.\n&quot;;&#10;        }&#10;    }catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        std::clog &lt;&lt; &quot;Database error: &quot; &lt;&lt; std::string(e.what()) &lt;&lt; '\n';&#10;    }&#10;    transaction.commit();&#10;    std::clog &lt;&lt; &quot;[Insert::InsertTrafegoLog] Trafego log inserted for phone: &quot; &lt;&lt; trafego-&gt;Phone &lt;&lt; std::endl;&#10;}&#10;&#10;void Insert::UpdateProcessado(const std::string &amp;telefone) const {&#10;    std::clog &lt;&lt; &quot;[Insert::UpdateProcessado] Updating processado for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        pqxx::result res = transaction.exec(pqxx::zview(&quot;UPDATE entrada_clt SET processado = true WHERE telefone = $1&quot;), pqxx::params(telefone));&#10;        if (!res.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;[Insert::UpdateProcessado][ERROR] No rows updated for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;        } else {&#10;            std::clog &lt;&lt; &quot;[Insert::UpdateProcessado][SUCCESS] Updated processado for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;        }&#10;    }catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        std::clog &lt;&lt; &quot;[Insert::UpdateProcessado][DB ERROR] &quot; &lt;&lt; e.what() &lt;&lt; &quot; for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;        return;&#10;    }&#10;    transaction.commit();&#10;    std::clog &lt;&lt; &quot;[Insert::UpdateProcessado] Processado updated for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;}&#10;&#10;void Insert::UpdateTabela(const std::string &amp;telefone) const {&#10;    std::clog &lt;&lt; &quot;[Insert::UpdateTabela] Updating tabela for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        pqxx::result res = transaction.exec(pqxx::zview(&quot;UPDATE parametros_disparos SET sent_today = sent_today + 1, last_message_time = NOW() WHERE connection_number = $1 &quot;), pqxx::params(telefone));&#10;        if (!res.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when updating Table.\n&quot;;&#10;        }&#10;    }catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        std::clog &lt;&lt; &quot;Database error: &quot; &lt;&lt; std::string(e.what()) &lt;&lt; '\n';&#10;    }&#10;    transaction.commit();&#10;    std::clog &lt;&lt; &quot;[Insert::UpdateTabela] Tabela updated for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;}&#10;&#10;void Insert::SetBanned(const std::string &amp;telefone) const {&#10;    std::clog &lt;&lt; &quot;[Insert::SetBanned] Setting banned for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        pqxx::result res = transaction.exec(pqxx::zview(&quot;UPDATE parametros_disparos SET is_banned = true, is_active = false WHERE connection_number = $1 &quot;), pqxx::params(telefone));&#10;        if (!res.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when updating ban.\n&quot;;&#10;        }&#10;    }catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        std::clog &lt;&lt; &quot;Database error: &quot; &lt;&lt; std::string(e.what()) &lt;&lt; '\n';&#10;    }&#10;    transaction.commit();&#10;    std::clog &lt;&lt; &quot;[Insert::SetBanned] Banned set for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;}&#10;&#10;void Insert::InsertInstance(const Instance_t&amp; instance) const {&#10;    std::clog &lt;&lt; &quot;[Insert::InsertInstance] Checking if instance exists: &quot; &lt;&lt; instance.InstanceNumber &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        pqxx::result res = transaction.exec_params(&#10;            &quot;SELECT 1 FROM parametros_disparos WHERE connection_number = $1 LIMIT 1&quot;, instance.InstanceNumber&#10;        );&#10;        if (res.empty()) {&#10;            std::clog &lt;&lt; &quot;[Insert::InsertInstance] Instance not found, inserting: &quot; &lt;&lt; instance.InstanceNumber &lt;&lt; std::endl;&#10;            transaction.exec_params(&#10;                &quot;INSERT INTO parametros_disparos (connection_name, connection_number, is_active, is_banned, daily_limit, sent_today) VALUES ($1, $2, true, false, 1000, 0)&quot;,&#10;                instance.InstanceName, instance.InstanceNumber&#10;            );&#10;            transaction.commit();&#10;            std::clog &lt;&lt; &quot;[Insert::InsertInstance] Instance inserted: &quot; &lt;&lt; instance.InstanceNumber &lt;&lt; std::endl;&#10;        } else {&#10;            std::clog &lt;&lt; &quot;[Insert::InsertInstance] Instance already exists: &quot; &lt;&lt; instance.InstanceNumber &lt;&lt; std::endl;&#10;            transaction.commit();&#10;        }&#10;    } catch (const pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        std::clog &lt;&lt; &quot;Database error: &quot; &lt;&lt; e.what() &lt;&lt; '\n';&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../../include/Database/Insert.h&quot;&#10;&#10;#include &lt;iostream&gt;&#10;&#10;void Insert::InsertLog(Message *msg) const {&#10;    std::clog &lt;&lt; &quot;[Insert::InsertLog] Inserting log for destino: &quot; &lt;&lt; msg-&gt;Destino &lt;&lt; &quot;, status: &quot; &lt;&lt; msg-&gt;Status &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        pqxx::result res = transaction.exec(pqxx::zview(&quot;INSERT INTO logs_disparo (source, source_name, destino, status, template) VALUES ($1, $2, $3, $4, $5)&quot;), pqxx::params(msg-&gt;Source, msg-&gt;SourceName, msg-&gt;Destino, msg-&gt;Status, msg-&gt;Template));&#10;        if (!res.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;[Insert::InsertLog][ERROR] No rows inserted for destino: &quot; &lt;&lt; msg-&gt;Destino &lt;&lt; &quot;, status: &quot; &lt;&lt; msg-&gt;Status &lt;&lt; std::endl;&#10;        } else {&#10;            std::clog &lt;&lt; &quot;[Insert::InsertLog][SUCCESS] Log inserted for destino: &quot; &lt;&lt; msg-&gt;Destino &lt;&lt; &quot;, status: &quot; &lt;&lt; msg-&gt;Status &lt;&lt; std::endl;&#10;        }&#10;    }catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        std::clog &lt;&lt; &quot;[Insert::InsertLog][DB ERROR] &quot; &lt;&lt; e.what() &lt;&lt; &quot; for destino: &quot; &lt;&lt; msg-&gt;Destino &lt;&lt; &quot;, status: &quot; &lt;&lt; msg-&gt;Status &lt;&lt; std::endl;&#10;        return;&#10;    }&#10;    transaction.commit();&#10;    std::clog &lt;&lt; &quot;[Insert::InsertLog] Log inserted for destino: &quot; &lt;&lt; msg-&gt;Destino &lt;&lt; std::endl;&#10;}&#10;&#10;void Insert::InsertTrafegoLog(Trafego *trafego) const {&#10;    std::clog &lt;&lt; &quot;[Insert::InsertTrafegoLog] Inserting trafego log for phone: &quot; &lt;&lt; trafego-&gt;Phone &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        pqxx::result res = transaction.exec(pqxx::zview(&quot;INSERT INTO logstrafegohuggy (name, phone, tag, timestamp) VALUES ($1, $2, $3, NOW())&quot;), pqxx::params(trafego-&gt;Name, trafego-&gt;Phone, trafego-&gt;Tag));&#10;        if (res.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;[Insert::InsertTrafegoLog][ERROR] No rows inserted for phone: &quot; &lt;&lt; trafego-&gt;Phone &lt;&lt; std::endl;&#10;        } else {&#10;            std::clog &lt;&lt; &quot;[Insert::InsertTrafegoLog][SUCCESS] Trafego log inserted for phone: &quot; &lt;&lt; trafego-&gt;Phone &lt;&lt; std::endl;&#10;        }&#10;    }catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        std::clog &lt;&lt; &quot;[Insert::InsertTrafegoLog][DB ERROR] &quot; &lt;&lt; e.what() &lt;&lt; &quot; for phone: &quot; &lt;&lt; trafego-&gt;Phone &lt;&lt; std::endl;&#10;        return;&#10;    }&#10;    transaction.commit();&#10;    std::clog &lt;&lt; &quot;[Insert::InsertTrafegoLog] Trafego log inserted for phone: &quot; &lt;&lt; trafego-&gt;Phone &lt;&lt; std::endl;&#10;}&#10;&#10;void Insert::UpdateProcessado(const std::string &amp;telefone) const {&#10;    std::clog &lt;&lt; &quot;[Insert::UpdateProcessado] Updating processado for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        pqxx::result res = transaction.exec(pqxx::zview(&quot;UPDATE entrada_clt SET processado = true WHERE telefone = $1&quot;), pqxx::params(telefone));&#10;        if (!res.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;[Insert::UpdateProcessado][ERROR] No rows updated for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;        } else {&#10;            std::clog &lt;&lt; &quot;[Insert::UpdateProcessado][SUCCESS] Updated processado for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;        }&#10;    }catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        std::clog &lt;&lt; &quot;[Insert::UpdateProcessado][DB ERROR] &quot; &lt;&lt; e.what() &lt;&lt; &quot; for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;        return;&#10;    }&#10;    transaction.commit();&#10;    std::clog &lt;&lt; &quot;[Insert::UpdateProcessado] Processado updated for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;}&#10;&#10;void Insert::UpdateTabela(const std::string &amp;telefone) const {&#10;    std::clog &lt;&lt; &quot;[Insert::UpdateTabela] Updating tabela for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        pqxx::result res = transaction.exec(pqxx::zview(&quot;UPDATE parametros_disparos SET sent_today = sent_today + 1, last_message_time = NOW() WHERE connection_number = $1 &quot;), pqxx::params(telefone));&#10;        if (!res.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when updating Table.\n&quot;;&#10;        }&#10;    }catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        std::clog &lt;&lt; &quot;Database error: &quot; &lt;&lt; std::string(e.what()) &lt;&lt; '\n';&#10;    }&#10;    transaction.commit();&#10;    std::clog &lt;&lt; &quot;[Insert::UpdateTabela] Tabela updated for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;}&#10;&#10;void Insert::SetBanned(const std::string &amp;telefone) const {&#10;    std::clog &lt;&lt; &quot;[Insert::SetBanned] Setting banned for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        pqxx::result res = transaction.exec(pqxx::zview(&quot;UPDATE parametros_disparos SET is_banned = true, is_active = false WHERE connection_number = $1 &quot;), pqxx::params(telefone));&#10;        if (!res.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when updating ban.\n&quot;;&#10;        }&#10;    }catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        std::clog &lt;&lt; &quot;Database error: &quot; &lt;&lt; std::string(e.what()) &lt;&lt; '\n';&#10;    }&#10;    transaction.commit();&#10;    std::clog &lt;&lt; &quot;[Insert::SetBanned] Banned set for telefone: &quot; &lt;&lt; telefone &lt;&lt; std::endl;&#10;}&#10;&#10;void Insert::InsertInstance(const Instance_t&amp; instance) const {&#10;    std::clog &lt;&lt; &quot;[Insert::InsertInstance] Checking if instance exists: &quot; &lt;&lt; instance.InstanceNumber &lt;&lt; std::endl;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        return;&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        pqxx::result res = transaction.exec_params(&#10;            &quot;SELECT 1 FROM parametros_disparos WHERE connection_number = $1 LIMIT 1&quot;, instance.InstanceNumber&#10;        );&#10;        if (res.empty()) {&#10;            std::clog &lt;&lt; &quot;[Insert::InsertInstance] Instance not found, inserting: &quot; &lt;&lt; instance.InstanceNumber &lt;&lt; std::endl;&#10;            transaction.exec_params(&#10;                &quot;INSERT INTO parametros_disparos (connection_name, connection_number, is_active, is_banned, daily_limit, sent_today) VALUES ($1, $2, true, false, 1000, 0)&quot;,&#10;                instance.InstanceName, instance.InstanceNumber&#10;            );&#10;            transaction.commit();&#10;            std::clog &lt;&lt; &quot;[Insert::InsertInstance] Instance inserted: &quot; &lt;&lt; instance.InstanceNumber &lt;&lt; std::endl;&#10;        } else {&#10;            std::clog &lt;&lt; &quot;[Insert::InsertInstance] Instance already exists: &quot; &lt;&lt; instance.InstanceNumber &lt;&lt; std::endl;&#10;            transaction.commit();&#10;        }&#10;    } catch (const pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        std::clog &lt;&lt; &quot;Database error: &quot; &lt;&lt; e.what() &lt;&lt; '\n';&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Validator.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Validator.cpp" />
              <option name="originalContent" value="#include &quot;../include/Validator.h&quot;&#10;#include &lt;chrono&gt;&#10;#include &quot;../include/Api/Api.h&quot;&#10;#include &quot;../include/Config.h&quot;&#10;#include &quot;../include/Database/Insert.h&quot;&#10;&#10;bool Validator::ValidateTime() {&#10;    const auto now = std::chrono::system_clock::now();&#10;    const auto time_t_now = std::chrono::system_clock::to_time_t(now);&#10;    const std::tm* tm_now = std::localtime(&amp;time_t_now);&#10;&#10;    if (tm_now-&gt;tm_wday == 0 || tm_now-&gt;tm_wday == 6) {&#10;        return false;&#10;    }&#10;&#10;    std::tm start_tm = *tm_now;&#10;    start_tm.tm_hour = 11;&#10;    start_tm.tm_min = 0;&#10;    start_tm.tm_sec = 0;&#10;    const auto start_time = std::chrono::system_clock::from_time_t(std::mktime(&amp;start_tm));&#10;&#10;    std::tm end_tm = *tm_now;&#10;    end_tm.tm_hour = 20;&#10;    end_tm.tm_min = 0;&#10;    end_tm.tm_sec = 0;&#10;&#10;    if (auto end_time = std::chrono::system_clock::from_time_t(std::mktime(&amp;end_tm)); start_time &lt;= end_time) {&#10;        return (now &gt;= start_time) &amp;&amp; (now &lt;= end_time);&#10;    } else {&#10;        return (now &gt;= start_time) || (now &lt;= end_time);&#10;    }&#10;}&#10;&#10;void Validator::ValidateConns() {&#10;    const Config cfg;&#10;    const auto&amp; env = cfg.GetEnv();&#10;&#10;    const auto conns = Api::GetConnections(env.LoginArca, env.PasswordArca);&#10;&#10;    if (conns.empty()) {&#10;        std::clog &lt;&lt; &quot;ERROR: No instances came from the api, skipping.\n&quot;;&#10;        return;&#10;    }&#10;&#10;    const auto insert = Insert(env.DbUrlV3);&#10;&#10;&#10;    for (const auto&amp; conn : conns) {&#10;        if (conn.Status == false) {&#10;            insert.SetBanned(conn.InstanceNumber);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/Validator.h&quot;&#10;#include &lt;chrono&gt;&#10;#include &quot;../include/Api/Api.h&quot;&#10;#include &quot;../include/Config.h&quot;&#10;#include &quot;../include/Database/Insert.h&quot;&#10;&#10;bool Validator::ValidateTime() {&#10;    std::clog &lt;&lt; &quot;[Validator::ValidateTime] Checking if current time is within allowed window&quot; &lt;&lt; std::endl;&#10;    const auto now = std::chrono::system_clock::now();&#10;    const auto time_t_now = std::chrono::system_clock::to_time_t(now);&#10;    const std::tm* tm_now = std::localtime(&amp;time_t_now);&#10;    std::clog &lt;&lt; &quot;[Validator::ValidateTime] tm_wday: &quot; &lt;&lt; tm_now-&gt;tm_wday &lt;&lt; &quot;, hour: &quot; &lt;&lt; tm_now-&gt;tm_hour &lt;&lt; std::endl;&#10;    if (tm_now-&gt;tm_wday == 0 || tm_now-&gt;tm_wday == 6) {&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateTime] Weekend detected, returning false&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;    std::tm start_tm = *tm_now;&#10;    start_tm.tm_hour = 11;&#10;    start_tm.tm_min = 0;&#10;    start_tm.tm_sec = 0;&#10;    const auto start_time = std::chrono::system_clock::from_time_t(std::mktime(&amp;start_tm));&#10;    std::tm end_tm = *tm_now;&#10;    end_tm.tm_hour = 20;&#10;    end_tm.tm_min = 0;&#10;    end_tm.tm_sec = 0;&#10;    if (auto end_time = std::chrono::system_clock::from_time_t(std::mktime(&amp;end_tm)); start_time &lt;= end_time) {&#10;        bool result = (now &gt;= start_time) &amp;&amp; (now &lt;= end_time);&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateTime] In range: &quot; &lt;&lt; result &lt;&lt; std::endl;&#10;        return result;&#10;    } else {&#10;        bool result = (now &gt;= start_time) || (now &lt;= end_time);&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateTime] In range (overnight): &quot; &lt;&lt; result &lt;&lt; std::endl;&#10;        return result;&#10;    }&#10;}&#10;&#10;void Validator::ValidateConns() {&#10;    std::clog &lt;&lt; &quot;[Validator::ValidateConns] Validating API connections&quot; &lt;&lt; std::endl;&#10;    const Config cfg;&#10;    const auto&amp; env = cfg.GetEnv();&#10;    const auto conns = Api::GetConnections(env.LoginArca, env.PasswordArca);&#10;    if (conns.empty()) {&#10;        std::clog &lt;&lt; &quot;ERROR: No instances came from the api, skipping.\n&quot;;&#10;        return;&#10;    }&#10;    const auto insert = Insert(env.DbUrlV3);&#10;    for (const auto&amp; conn : conns) {&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateConns] Checking instance: &quot; &lt;&lt; conn.InstanceNumber &lt;&lt; &quot;, status: &quot; &lt;&lt; conn.Status &lt;&lt; std::endl;&#10;        if (conn.Status == false) {&#10;            std::clog &lt;&lt; &quot;[Validator::ValidateConns] Marking as banned: &quot; &lt;&lt; conn.InstanceNumber &lt;&lt; std::endl;&#10;            insert.SetBanned(conn.InstanceNumber);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.cpp" />
              <option name="originalContent" value="#include &lt;iostream&gt;&#10;#include &lt;thread&gt;&#10;&#10;#include &quot;../include/Config.h&quot;&#10;#include &quot;../include/Utils.h&quot;&#10;#include &quot;../include/Database/Fetch.h&quot;&#10;#include &quot;../include/Validator.h&quot;&#10;#include &quot;../include/Api/Api.h&quot;&#10;#include &quot;../include/Database/Insert.h&quot;&#10;&#10;[[noreturn]] int main() {&#10;    std::clog &lt;&lt; &quot;[main] Starting application&quot; &lt;&lt; std::endl;&#10;    const Config cfg;&#10;    const auto&amp; env = cfg.GetEnv();&#10;    std::clog &lt;&lt; &quot;[main] Entering main loop&quot; &lt;&lt; std::endl;&#10;    while (true) {&#10;        if (!Validator::ValidateTime()) {&#10;            std::clog &lt;&lt; &quot;Not in working time, waiting...\n&quot;;&#10;            std::this_thread::sleep_for(std::chrono::seconds(5));&#10;            continue;&#10;        }&#10;        std::clog &lt;&lt; &quot;[main] Validating connections&quot; &lt;&lt; std::endl;&#10;        Validator::ValidateConns();&#10;        std::clog &lt;&lt; &quot;[main] Fetching main_db&quot; &lt;&lt; std::endl;&#10;        auto main_db = Fetch(env.DbUrl);&#10;        std::clog &lt;&lt; &quot;[main] Fetching leads&quot; &lt;&lt; std::endl;&#10;        auto leads = main_db.FetchBolsa();&#10;        std::clog &lt;&lt; &quot;[main] Fetching template&quot; &lt;&lt; std::endl;&#10;        const auto template_t = main_db.FetchTemplates();&#10;        std::clog &lt;&lt; &quot;[main] Fetching v3_db&quot; &lt;&lt; std::endl;&#10;        auto v3_db = Fetch(env.DbUrlV3);&#10;        std::clog &lt;&lt; &quot;[main] Fetching instances&quot; &lt;&lt; std::endl;&#10;        auto instances = v3_db.FetchInstances();&#10;        std::clog &lt;&lt; &quot;[main] Fetching API connections&quot; &lt;&lt; std::endl;&#10;        auto api_conns = Api::GetConnections(env.LoginArca, env.PasswordArca);&#10;        auto v3_db_ins = Insert(env.DbUrlV3);&#10;        for (const auto&amp; api_conn : api_conns) {&#10;            v3_db_ins.InsertInstance(api_conn);&#10;        }&#10;        std::clog &lt;&lt; &quot;[main] Preparing Insert objects&quot; &lt;&lt; std::endl;&#10;        auto main_db_ins = Insert(env.DbUrl);&#10;        size_t instanceIndex = 0;&#10;        size_t totalInstances = instances.size();&#10;        for (auto it = leads.begin(); it != leads.end(); ++it) {&#10;            std::clog &lt;&lt; &quot;[main] Processing lead: &quot; &lt;&lt; it-&gt;Telefone &lt;&lt; std::endl;&#10;            main_db_ins.UpdateProcessado(it-&gt;Telefone);&#10;            auto phone = Utils::FormatPhone(it-&gt;Telefone);&#10;            const auto&amp; instance = instances[instanceIndex];&#10;            std::clog &lt;&lt; &quot;[main] Using instance: &quot; &lt;&lt; instance.InstanceNumber &lt;&lt; std::endl;&#10;            instanceIndex = (instanceIndex + 1) % totalInstances;&#10;            Request req = {&#10;                .ApiKey = instance.Token,&#10;                .Number = phone,&#10;                .Body = template_t&#10;            };&#10;            std::clog &lt;&lt; &quot;[main] Sending message via API&quot; &lt;&lt; std::endl;&#10;            auto status = Api::SendMessageApi(&amp;req);&#10;            auto msg = Message {&#10;                .Source = instance.InstanceNumber,&#10;                .SourceName = instance.InstanceName,&#10;                .Destino = phone,&#10;                .Status = status ? &quot;sucesso&quot; : &quot;erro&quot;,&#10;                .Template = template_t&#10;            };&#10;            std::clog &lt;&lt; &quot;[main] Inserting log into v3_db_ins&quot; &lt;&lt; std::endl;&#10;            v3_db_ins.InsertLog(&amp;msg);&#10;            auto tra = Insert(env.DbUrlTrafego);&#10;            if (status) {&#10;                std::clog &lt;&lt; &quot;[main] Message sent successfully, inserting trafego log&quot; &lt;&lt; std::endl;&#10;                Trafego tr = Trafego {&#10;                    .Name = it-&gt;Nome,&#10;                    .Phone = phone,&#10;                    .Tag = it-&gt;Tag&#10;                };&#10;                tra.InsertTrafegoLog(&amp;tr);&#10;            } else {&#10;                std::clog &lt;&lt; &quot;[main] Message failed to send&quot; &lt;&lt; std::endl;&#10;            }&#10;            std::clog &lt;&lt; &quot;[main] Sleeping 5 seconds before next lead&quot; &lt;&lt; std::endl;&#10;            std::this_thread::sleep_for(std::chrono::seconds(15));&#10;        }&#10;        std::clog &lt;&lt; &quot;[main] Sleeping 5 seconds before next main loop iteration&quot; &lt;&lt; std::endl;&#10;        std::this_thread::sleep_for(std::chrono::minutes(13));&#10;&#10;    }&#10;}" />
              <option name="updatedContent" value="#include &lt;iostream&gt;&#10;#include &lt;thread&gt;&#10;#include &lt;random&gt;&#10;&#10;#include &quot;../include/Config.h&quot;&#10;#include &quot;../include/Utils.h&quot;&#10;#include &quot;../include/Database/Fetch.h&quot;&#10;#include &quot;../include/Validator.h&quot;&#10;#include &quot;../include/Api/Api.h&quot;&#10;#include &quot;../include/Database/Insert.h&quot;&#10;&#10;[[noreturn]] int main() {&#10;    std::clog &lt;&lt; &quot;[main] Starting application&quot; &lt;&lt; std::endl;&#10;    const Config cfg;&#10;    const auto&amp; env = cfg.GetEnv();&#10;    std::clog &lt;&lt; &quot;[main] Entering main loop&quot; &lt;&lt; std::endl;&#10;    while (true) {&#10;        if (!Validator::ValidateTime()) {&#10;            std::clog &lt;&lt; &quot;Not in working time, waiting...\n&quot;;&#10;            std::this_thread::sleep_for(std::chrono::seconds(5));&#10;            continue;&#10;        }&#10;        std::clog &lt;&lt; &quot;[main] Validating connections&quot; &lt;&lt; std::endl;&#10;        Validator::ValidateConns();&#10;        std::clog &lt;&lt; &quot;[main] Fetching main_db&quot; &lt;&lt; std::endl;&#10;        auto main_db = Fetch(env.DbUrl);&#10;        std::clog &lt;&lt; &quot;[main] Fetching leads&quot; &lt;&lt; std::endl;&#10;        auto leads = main_db.FetchBolsa();&#10;        std::clog &lt;&lt; &quot;[main] Fetching template&quot; &lt;&lt; std::endl;&#10;        const auto template_t = main_db.FetchTemplates();&#10;        std::clog &lt;&lt; &quot;[main] Fetching v3_db&quot; &lt;&lt; std::endl;&#10;        auto v3_db = Fetch(env.DbUrlV3);&#10;        std::clog &lt;&lt; &quot;[main] Fetching instances&quot; &lt;&lt; std::endl;&#10;        auto instances = v3_db.FetchInstances();&#10;        std::clog &lt;&lt; &quot;[main] Fetching API connections&quot; &lt;&lt; std::endl;&#10;        auto api_conns = Api::GetConnections(env.LoginArca, env.PasswordArca);&#10;        auto v3_db_ins = Insert(env.DbUrlV3);&#10;        for (const auto&amp; api_conn : api_conns) {&#10;            v3_db_ins.InsertInstance(api_conn);&#10;        }&#10;        std::clog &lt;&lt; &quot;[main] Preparing Insert objects&quot; &lt;&lt; std::endl;&#10;        auto main_db_ins = Insert(env.DbUrl);&#10;        size_t instanceIndex = 0;&#10;        size_t totalInstances = instances.size();&#10;        for (auto it = leads.begin(); it != leads.end(); ++it) {&#10;            std::clog &lt;&lt; &quot;[main] Processing lead: &quot; &lt;&lt; it-&gt;Telefone &lt;&lt; std::endl;&#10;            main_db_ins.UpdateProcessado(it-&gt;Telefone);&#10;            auto phone = Utils::FormatPhone(it-&gt;Telefone);&#10;            const auto&amp; instance = instances[instanceIndex];&#10;            std::clog &lt;&lt; &quot;[main] Using instance: &quot; &lt;&lt; instance.InstanceNumber &lt;&lt; std::endl;&#10;            instanceIndex = (instanceIndex + 1) % totalInstances;&#10;            Request req = {&#10;                .ApiKey = instance.Token,&#10;                .Number = phone,&#10;                .Body = template_t&#10;            };&#10;            std::clog &lt;&lt; &quot;[main] Sending message via API&quot; &lt;&lt; std::endl;&#10;            auto status = Api::SendMessageApi(&amp;req);&#10;            auto msg = Message {&#10;                .Source = instance.InstanceNumber,&#10;                .SourceName = instance.InstanceName,&#10;                .Destino = phone,&#10;                .Status = status ? &quot;sucesso&quot; : &quot;erro&quot;,&#10;                .Template = template_t&#10;            };&#10;            std::clog &lt;&lt; &quot;[main] Inserting log into v3_db_ins&quot; &lt;&lt; std::endl;&#10;            v3_db_ins.InsertLog(&amp;msg);&#10;            auto tra = Insert(env.DbUrlTrafego);&#10;            if (status) {&#10;                std::clog &lt;&lt; &quot;[main] Message sent successfully, inserting trafego log&quot; &lt;&lt; std::endl;&#10;                Trafego tr = Trafego {&#10;                    .Name = it-&gt;Nome,&#10;                    .Phone = phone,&#10;                    .Tag = it-&gt;Tag&#10;                };&#10;                tra.InsertTrafegoLog(&amp;tr);&#10;            } else {&#10;                std::clog &lt;&lt; &quot;[main] Message failed to send&quot; &lt;&lt; std::endl;&#10;            }&#10;            std::clog &lt;&lt; &quot;[main] Sleeping ~10 seconds (+/-10%) before next lead&quot; &lt;&lt; std::endl;&#10;            {&#10;                static std::random_device rd;&#10;                static std::mt19937 gen(rd());&#10;                std::uniform_real_distribution&lt;&gt; dis(0.9, 1.1);&#10;                double factor = dis(gen);&#10;                int sleep_ms = static_cast&lt;int&gt;(10000 * factor);&#10;                std::this_thread::sleep_for(std::chrono::milliseconds(sleep_ms));&#10;            }&#10;        }&#10;        std::clog &lt;&lt; &quot;[main] Sleeping ~13 minutes (+/-10%) before next main loop iteration&quot; &lt;&lt; std::endl;&#10;        {&#10;            static std::random_device rd;&#10;            static std::mt19937 gen(rd());&#10;            std::uniform_real_distribution&lt;&gt; dis(0.9, 1.1);&#10;            double factor = dis(gen);&#10;            int sleep_ms = static_cast&lt;int&gt;(13 * 60 * 1000 * factor);&#10;            std::this_thread::sleep_for(std::chrono::milliseconds(sleep_ms));&#10;        }&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>