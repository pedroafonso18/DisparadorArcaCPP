<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Api.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Api.cpp" />
              <option name="originalContent" value="#include &quot;../include/Api/Api.h&quot;&#10;#include &lt;curl/curl.h&gt;&#10;#include &quot;../third_party/json.h&quot;&#10;#include &lt;format&gt;&#10;#include &lt;iostream&gt;&#10;&#10;size_t Api::WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {&#10;    size_t totalSize = size * nmemb;&#10;    auto* resp = static_cast&lt;std::string*&gt;(userp);&#10;    resp-&gt;append(static_cast&lt;char*&gt;(contents), totalSize);&#10;    return totalSize;&#10;}&#10;&#10;bool Api::SendMessageApi(Request *req) {&#10;    std::clog &lt;&lt; &quot;[Api::SendMessageApi] Called with number: &quot; &lt;&lt; req-&gt;Number &lt;&lt; &quot;, body: &quot; &lt;&lt; req-&gt;Body &lt;&lt; std::endl;&#10;    const std::string url = &quot;https://bk.atendimento-meuconsig.com.br/api/messages/send&quot;;&#10;    CURL* curl = curl_easy_init();&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return false;&#10;    }&#10;    nlohmann::json req_body = {&#10;        {&quot;number&quot;, req-&gt;Number},&#10;        {&quot;body&quot;, req-&gt;Body},&#10;        {&quot;queueId&quot;, 2},&#10;        {&quot;sendSignature&quot;, false},&#10;        {&quot;closeTicket&quot;, true},&#10;        {&quot;userId&quot;, &quot;&quot;}&#10;    };&#10;    std::string str_bod = req_body.dump();&#10;    struct curl_slist* headers = nullptr;&#10;    const std::string auth = std::format(&quot;Authorization: Bearer {}&quot;, req-&gt;ApiKey);&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/json&quot;);&#10;    headers = curl_slist_append(headers, auth.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, str_bod.c_str());&#10;    std::clog &lt;&lt; &quot;[Api::SendMessageApi] Sending POST to: &quot; &lt;&lt; url &lt;&lt; std::endl;&#10;    CURLcode res = curl_easy_perform(curl);&#10;    long http_code = 0;&#10;    if (res == CURLE_OK) {&#10;        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;http_code);&#10;        std::clog &lt;&lt; &quot;[Api::SendMessageApi] HTTP code: &quot; &lt;&lt; http_code &lt;&lt; std::endl;&#10;    } else {&#10;        std::clog &lt;&lt; &quot;ERROR: curl_easy_perform failed: &quot; &lt;&lt; curl_easy_strerror(res) &lt;&lt; &quot;\n&quot;;&#10;    }&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    std::clog &lt;&lt; &quot;[Api::SendMessageApi] Finished with status: &quot; &lt;&lt; (res == CURLE_OK &amp;&amp; http_code &gt;= 200 &amp;&amp; http_code &lt; 300) &lt;&lt; std::endl;&#10;    return (res == CURLE_OK &amp;&amp; http_code &gt;= 200 &amp;&amp; http_code &lt; 300);&#10;}&#10;&#10;std::string Api::Login(const std::string &amp;email, const std::string &amp;password) {&#10;    std::clog &lt;&lt; &quot;[Api::Login] Called with email: &quot; &lt;&lt; email &lt;&lt; std::endl;&#10;    const std::string url = &quot;https://bk.atendimento-meuconsig.com.br/auth/login&quot;;&#10;    CURL* curl = curl_easy_init();&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;    nlohmann::json req_body = {&#10;        {&quot;email&quot;, email},&#10;        {&quot;password&quot;, password}&#10;    };&#10;    std::string respBody;&#10;    std::string str_bod = req_body.dump();&#10;    struct curl_slist* headers = nullptr;&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/json&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, str_bod.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBody);&#10;    std::clog &lt;&lt; &quot;[Api::Login] Sending POST to: &quot; &lt;&lt; url &lt;&lt; std::endl;&#10;    CURLcode res = curl_easy_perform(curl);&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    if (res != CURLE_OK) {&#10;        std::clog &lt;&lt; &quot;ERROR: curl_easy_perform failed: &quot; &lt;&lt; curl_easy_strerror(res) &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;    std::clog &lt;&lt; &quot;[Api::Login] Raw response: &quot; &lt;&lt; respBody &lt;&lt; std::endl;&#10;    try {&#10;        auto json_resp = nlohmann::json::parse(respBody);&#10;        if (json_resp.contains(&quot;token&quot;)) {&#10;            std::clog &lt;&lt; &quot;[Api::Login] Login successful, token received.&quot; &lt;&lt; std::endl;&#10;            return json_resp[&quot;token&quot;].get&lt;std::string&gt;();&#10;        } else {&#10;            std::clog &lt;&lt; &quot;ERROR: No token in response\n&quot;;&#10;            return &quot;&quot;;&#10;        }&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to parse JSON: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;}&#10;&#10;std::vector&lt;Instance_t&gt; Api::GetConnections(const std::string &amp;email, const std::string &amp;password) {&#10;    std::clog &lt;&lt; &quot;[Api::GetConnections] Called with email: &quot; &lt;&lt; email &lt;&lt; std::endl;&#10;    const std::string url = &quot;https://bk.atendimento-meuconsig.com.br/whatsapp?companyId=2&amp;session=0&quot;;&#10;    const std::string token = Login(email, password);&#10;    std::string respBody;&#10;    CURL* curl = curl_easy_init();&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return {};&#10;    }&#10;    struct curl_slist* headers = nullptr;&#10;    const std::string auth = std::format(&quot;Authorization: Bearer {}&quot;, token);&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/json&quot;);&#10;    headers = curl_slist_append(headers, auth.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;GET&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBody);&#10;    std::clog &lt;&lt; &quot;[Api::GetConnections] Sending GET to: &quot; &lt;&lt; url &lt;&lt; std::endl;&#10;    CURLcode res = curl_easy_perform(curl);&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    if (res != CURLE_OK) {&#10;        std::clog &lt;&lt; &quot;ERROR: curl_easy_perform failed: &quot; &lt;&lt; curl_easy_strerror(res) &lt;&lt; &quot;\n&quot;;&#10;        return {};&#10;    }&#10;    std::vector&lt;Instance_t&gt; instances;&#10;    try {&#10;        auto json_resp = nlohmann::json::parse(respBody);&#10;        if (!json_resp.is_array()) {&#10;            std::clog &lt;&lt; &quot;ERROR: Expected array of connections in JSON\n&quot;;&#10;            return {};&#10;        }&#10;        for (const auto&amp; item : json_resp) {&#10;            Instance_t inst;&#10;            inst.Id = item.value(&quot;id&quot;, 0);&#10;            inst.InstanceName = item.value(&quot;name&quot;, &quot;&quot;);&#10;            inst.InstanceNumber = item.value(&quot;number&quot;, &quot;&quot;);&#10;            inst.Status = item.value(&quot;status&quot;, &quot;&quot;) == &quot;CONNECTED&quot;;&#10;            std::clog &lt;&lt; &quot;[Api::GetConnections] Instance: &quot; &lt;&lt; inst.InstanceName &lt;&lt; &quot;, Number: &quot; &lt;&lt; inst.InstanceNumber &lt;&lt; &quot;, Status: &quot; &lt;&lt; inst.Status &lt;&lt; std::endl;&#10;            instances.push_back(inst);&#10;        }&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to parse JSON: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return {};&#10;    }&#10;    std::clog &lt;&lt; &quot;[Api::GetConnections] Returning &quot; &lt;&lt; instances.size() &lt;&lt; &quot; instances.&quot; &lt;&lt; std::endl;&#10;    return instances;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/Api/Api.h&quot;&#10;#include &lt;curl/curl.h&gt;&#10;#include &quot;../third_party/json.h&quot;&#10;#include &lt;format&gt;&#10;#include &lt;iostream&gt;&#10;&#10;size_t Api::WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {&#10;    size_t totalSize = size * nmemb;&#10;    auto* resp = static_cast&lt;std::string*&gt;(userp);&#10;    resp-&gt;append(static_cast&lt;char*&gt;(contents), totalSize);&#10;    return totalSize;&#10;}&#10;&#10;bool Api::SendMessageApi(Request *req) {&#10;    std::clog &lt;&lt; &quot;[Api::SendMessageApi] Called with number: &quot; &lt;&lt; req-&gt;Number &lt;&lt; &quot;, body: &quot; &lt;&lt; req-&gt;Body &lt;&lt; std::endl;&#10;    const std::string url = &quot;https://bk.atendimento-meuconsig.com.br/api/messages/send&quot;;&#10;    CURL* curl = curl_easy_init();&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return false;&#10;    }&#10;    nlohmann::json req_body = {&#10;        {&quot;number&quot;, req-&gt;Number},&#10;        {&quot;body&quot;, req-&gt;Body},&#10;        {&quot;queueId&quot;, 2},&#10;        {&quot;sendSignature&quot;, false},&#10;        {&quot;closeTicket&quot;, true},&#10;        {&quot;userId&quot;, &quot;&quot;}&#10;    };&#10;    std::string str_bod = req_body.dump();&#10;    struct curl_slist* headers = nullptr;&#10;    const std::string auth = std::format(&quot;Authorization: Bearer {}&quot;, req-&gt;ApiKey);&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/json&quot;);&#10;    headers = curl_slist_append(headers, auth.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, str_bod.c_str());&#10;    std::clog &lt;&lt; &quot;[Api::SendMessageApi] Sending POST to: &quot; &lt;&lt; url &lt;&lt; std::endl;&#10;    CURLcode res = curl_easy_perform(curl);&#10;    long http_code = 0;&#10;    if (res == CURLE_OK) {&#10;        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;http_code);&#10;        std::clog &lt;&lt; &quot;[Api::SendMessageApi] HTTP code: &quot; &lt;&lt; http_code &lt;&lt; std::endl;&#10;    } else {&#10;        std::clog &lt;&lt; &quot;ERROR: curl_easy_perform failed: &quot; &lt;&lt; curl_easy_strerror(res) &lt;&lt; &quot;\n&quot;;&#10;    }&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    std::clog &lt;&lt; &quot;[Api::SendMessageApi] Finished with status: &quot; &lt;&lt; (res == CURLE_OK &amp;&amp; http_code &gt;= 200 &amp;&amp; http_code &lt; 300) &lt;&lt; std::endl;&#10;    return (res == CURLE_OK &amp;&amp; http_code &gt;= 200 &amp;&amp; http_code &lt; 300);&#10;}&#10;&#10;std::string Api::Login(const std::string &amp;email, const std::string &amp;password) {&#10;    std::clog &lt;&lt; &quot;[Api::Login] Called with email: &quot; &lt;&lt; email &lt;&lt; std::endl;&#10;    const std::string url = &quot;https://bk.atendimento-meuconsig.com.br/auth/login&quot;;&#10;    CURL* curl = curl_easy_init();&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;    nlohmann::json req_body = {&#10;        {&quot;email&quot;, email},&#10;        {&quot;password&quot;, password}&#10;    };&#10;    std::string respBody;&#10;    std::string str_bod = req_body.dump();&#10;    struct curl_slist* headers = nullptr;&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/json&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, str_bod.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBody);&#10;    std::clog &lt;&lt; &quot;[Api::Login] Sending POST to: &quot; &lt;&lt; url &lt;&lt; std::endl;&#10;    CURLcode res = curl_easy_perform(curl);&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    if (res != CURLE_OK) {&#10;        std::clog &lt;&lt; &quot;ERROR: curl_easy_perform failed: &quot; &lt;&lt; curl_easy_strerror(res) &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;    std::clog &lt;&lt; &quot;[Api::Login] Raw response: &quot; &lt;&lt; respBody &lt;&lt; std::endl;&#10;    try {&#10;        auto json_resp = nlohmann::json::parse(respBody);&#10;        if (json_resp.contains(&quot;token&quot;)) {&#10;            std::clog &lt;&lt; &quot;[Api::Login] Login successful, token received.&quot; &lt;&lt; std::endl;&#10;            return json_resp[&quot;token&quot;].get&lt;std::string&gt;();&#10;        } else {&#10;            std::clog &lt;&lt; &quot;ERROR: No token in response\n&quot;;&#10;            return &quot;&quot;;&#10;        }&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to parse JSON: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return &quot;&quot;;&#10;    }&#10;}&#10;&#10;std::vector&lt;Instance_t&gt; Api::GetConnections(const std::string &amp;email, const std::string &amp;password) {&#10;    std::clog &lt;&lt; &quot;[Api::GetConnections] Called with email: &quot; &lt;&lt; email &lt;&lt; std::endl;&#10;    const std::string url = &quot;https://bk.atendimento-meuconsig.com.br/whatsapp?companyId=2&amp;session=0&quot;;&#10;    const std::string token = Login(email, password);&#10;    std::string respBody;&#10;    CURL* curl = curl_easy_init();&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return {};&#10;    }&#10;    struct curl_slist* headers = nullptr;&#10;    const std::string auth = std::format(&quot;Authorization: Bearer {}&quot;, token);&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/json&quot;);&#10;    headers = curl_slist_append(headers, auth.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;GET&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBody);&#10;    std::clog &lt;&lt; &quot;[Api::GetConnections] Sending GET to: &quot; &lt;&lt; url &lt;&lt; std::endl;&#10;    CURLcode res = curl_easy_perform(curl);&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    if (res != CURLE_OK) {&#10;        std::clog &lt;&lt; &quot;ERROR: curl_easy_perform failed: &quot; &lt;&lt; curl_easy_strerror(res) &lt;&lt; &quot;\n&quot;;&#10;        return {};&#10;    }&#10;    std::vector&lt;Instance_t&gt; instances;&#10;    try {&#10;        auto json_resp = nlohmann::json::parse(respBody);&#10;        std::clog &lt;&lt; &quot;[Api::GetConnections] Raw JSON: &quot; &lt;&lt; json_resp.dump() &lt;&lt; std::endl;&#10;        if (!json_resp.is_array()) {&#10;            std::clog &lt;&lt; &quot;ERROR: Expected array of connections in JSON\n&quot;;&#10;            return {};&#10;        }&#10;        for (const auto&amp; item : json_resp) {&#10;            Instance_t inst;&#10;            inst.Id = item.value(&quot;id&quot;, 0);&#10;            inst.InstanceName = item.value(&quot;name&quot;, &quot;&quot;);&#10;            inst.InstanceNumber = item.value(&quot;number&quot;, &quot;&quot;);&#10;            inst.Status = item.value(&quot;status&quot;, &quot;&quot;) == &quot;CONNECTED&quot;;&#10;            std::clog &lt;&lt; &quot;[Api::GetConnections] Instance: &quot; &lt;&lt; inst.InstanceName &lt;&lt; &quot;, Number: &quot; &lt;&lt; inst.InstanceNumber &lt;&lt; &quot;, Status: &quot; &lt;&lt; inst.Status &lt;&lt; std::endl;&#10;            instances.push_back(inst);&#10;        }&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to parse JSON: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;        return {};&#10;    }&#10;    std::clog &lt;&lt; &quot;[Api::GetConnections] Returning &quot; &lt;&lt; instances.size() &lt;&lt; &quot; instances.&quot; &lt;&lt; std::endl;&#10;    return instances;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Validator.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Validator.cpp" />
              <option name="originalContent" value="#include &quot;../include/Validator.h&quot;&#10;#include &lt;chrono&gt;&#10;#include &quot;../include/Api/Api.h&quot;&#10;#include &quot;../include/Config.h&quot;&#10;#include &quot;../include/Database/Insert.h&quot;&#10;&#10;bool Validator::ValidateTime() {&#10;    std::clog &lt;&lt; &quot;[Validator::ValidateTime] Checking if current time is within allowed window&quot; &lt;&lt; std::endl;&#10;    const auto now = std::chrono::system_clock::now();&#10;    const auto time_t_now = std::chrono::system_clock::to_time_t(now);&#10;    const std::tm* tm_now = std::localtime(&amp;time_t_now);&#10;    std::clog &lt;&lt; &quot;[Validator::ValidateTime] tm_wday: &quot; &lt;&lt; tm_now-&gt;tm_wday &lt;&lt; &quot;, hour: &quot; &lt;&lt; tm_now-&gt;tm_hour &lt;&lt; std::endl;&#10;    if (tm_now-&gt;tm_wday == 0 || tm_now-&gt;tm_wday == 6) {&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateTime] Weekend detected, returning false&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;    std::tm start_tm = *tm_now;&#10;    start_tm.tm_hour = 10;&#10;    start_tm.tm_min = 0;&#10;    start_tm.tm_sec = 0;&#10;    const auto start_time = std::chrono::system_clock::from_time_t(std::mktime(&amp;start_tm));&#10;    std::tm end_tm = *tm_now;&#10;    end_tm.tm_hour = 20;&#10;    end_tm.tm_min = 0;&#10;    end_tm.tm_sec = 0;&#10;    if (auto end_time = std::chrono::system_clock::from_time_t(std::mktime(&amp;end_tm)); start_time &lt;= end_time) {&#10;        bool result = (now &gt;= start_time) &amp;&amp; (now &lt;= end_time);&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateTime] In range: &quot; &lt;&lt; result &lt;&lt; std::endl;&#10;        return result;&#10;    } else {&#10;        bool result = (now &gt;= start_time) || (now &lt;= end_time);&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateTime] In range (overnight): &quot; &lt;&lt; result &lt;&lt; std::endl;&#10;        return result;&#10;    }&#10;}&#10;&#10;void Validator::ValidateConns() {&#10;    std::clog &lt;&lt; &quot;[Validator::ValidateConns] Validating API connections&quot; &lt;&lt; std::endl;&#10;    const Config cfg;&#10;    const auto&amp; env = cfg.GetEnv();&#10;    const auto conns = Api::GetConnections(env.LoginArca, env.PasswordArca);&#10;    if (conns.empty()) {&#10;        std::clog &lt;&lt; &quot;ERROR: No instances came from the api, skipping.\n&quot;;&#10;        return;&#10;    }&#10;    const auto insert = Insert(env.DbUrlV3);&#10;    for (const auto&amp; conn : conns) {&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateConns] Checking instance: &quot; &lt;&lt; conn.InstanceNumber &lt;&lt; &quot;, status: &quot; &lt;&lt; conn.Status &lt;&lt; std::endl;&#10;        if (conn.Status == false) {&#10;            std::clog &lt;&lt; &quot;[Validator::ValidateConns] Marking as banned: &quot; &lt;&lt; conn.InstanceNumber &lt;&lt; std::endl;&#10;            insert.SetBanned(conn.InstanceNumber);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/Validator.h&quot;&#10;#include &lt;chrono&gt;&#10;#include &quot;../include/Api/Api.h&quot;&#10;#include &quot;../include/Config.h&quot;&#10;#include &quot;../include/Database/Insert.h&quot;&#10;&#10;bool Validator::ValidateTime() {&#10;    std::clog &lt;&lt; &quot;[Validator::ValidateTime] Checking if current time is within allowed window&quot; &lt;&lt; std::endl;&#10;    const auto now = std::chrono::system_clock::now();&#10;    const auto time_t_now = std::chrono::system_clock::to_time_t(now);&#10;    const std::tm* tm_now = std::localtime(&amp;time_t_now);&#10;    std::clog &lt;&lt; &quot;[Validator::ValidateTime] tm_wday: &quot; &lt;&lt; tm_now-&gt;tm_wday &lt;&lt; &quot;, hour: &quot; &lt;&lt; tm_now-&gt;tm_hour &lt;&lt; std::endl;&#10;    if (tm_now-&gt;tm_wday == 0 || tm_now-&gt;tm_wday == 6) {&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateTime] Weekend detected, returning false&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;    std::tm start_tm = *tm_now;&#10;    start_tm.tm_hour = 10;&#10;    start_tm.tm_min = 0;&#10;    start_tm.tm_sec = 0;&#10;    const auto start_time = std::chrono::system_clock::from_time_t(std::mktime(&amp;start_tm));&#10;    std::tm end_tm = *tm_now;&#10;    end_tm.tm_hour = 20;&#10;    end_tm.tm_min = 0;&#10;    end_tm.tm_sec = 0;&#10;    if (auto end_time = std::chrono::system_clock::from_time_t(std::mktime(&amp;end_tm)); start_time &lt;= end_time) {&#10;        bool result = (now &gt;= start_time) &amp;&amp; (now &lt;= end_time);&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateTime] In range: &quot; &lt;&lt; result &lt;&lt; std::endl;&#10;        return result;&#10;    } else {&#10;        bool result = (now &gt;= start_time) || (now &lt;= end_time);&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateTime] In range (overnight): &quot; &lt;&lt; result &lt;&lt; std::endl;&#10;        return result;&#10;    }&#10;}&#10;&#10;void Validator::ValidateConns() {&#10;    std::clog &lt;&lt; &quot;[Validator::ValidateConns] Validating API connections&quot; &lt;&lt; std::endl;&#10;    const Config cfg;&#10;    const auto&amp; env = cfg.GetEnv();&#10;    const auto conns = Api::GetConnections(env.LoginArca, env.PasswordArca);&#10;    if (conns.empty()) {&#10;        std::clog &lt;&lt; &quot;ERROR: No instances came from the api, skipping.\n&quot;;&#10;        return;&#10;    }&#10;    const auto insert = Insert(env.DbUrlV3);&#10;    for (const auto&amp; conn : conns) {&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateConns] Checking instance: &quot; &lt;&lt; conn.InstanceNumber &lt;&lt; &quot;, status: &quot; &lt;&lt; conn.Status &lt;&lt; std::endl;&#10;        std::clog &lt;&lt; &quot;[Validator::ValidateConns] Token: &quot; &lt;&lt; conn.Token &lt;&lt; std::endl;&#10;        if (conn.Status == false) {&#10;            std::clog &lt;&lt; &quot;[Validator::ValidateConns] Marking as banned: &quot; &lt;&lt; conn.InstanceNumber &lt;&lt; std::endl;&#10;            insert.SetBanned(conn.InstanceNumber);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>